{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction to Grizabella","text":"<p>Welcome to Grizabella, a powerful tri-layer memory framework designed to enhance Large Language Model (LLM) solutions by providing robust, multi-faceted data storage and retrieval capabilities.</p>"},{"location":"#what-is-grizabella","title":"What is Grizabella?","text":"<p>Grizabella is engineered to serve as a comprehensive memory backbone for applications leveraging LLMs. It allows developers to seamlessly integrate structured, unstructured, and graph-based data, enabling LLMs to access and utilize a rich, context-aware knowledge base. This facilitates more intelligent, accurate, and personalized interactions.</p>"},{"location":"#key-features","title":"Key Features","text":"<p>Grizabella offers a suite of features to empower your LLM applications:</p> <ul> <li>Versatile Data Storage:</li> <li>SQLite Integration: For robust relational data storage, ideal for structured metadata and transactional information.</li> <li>LanceDB Integration: For efficient vector storage and similarity search, crucial for semantic retrieval and embedding-based lookups.</li> <li>Kuzu Integration: For powerful graph database capabilities, enabling the modeling and querying of complex relationships between data entities.</li> <li>Unified Python API: A consistent and intuitive Python library (<code>grizabella</code>) for interacting with all three database layers, simplifying development and data management.</li> <li>PySide6 User Interface: A standalone desktop application (<code>grizabella-ui</code>) providing a visual way to manage schemas, explore data, and interact with the Grizabella framework.</li> <li>MCP Server: A Model Context Protocol (MCP) server (<code>grizabella-mcp</code>) allowing other applications or agents to interact with Grizabella's data and functionalities through a standardized protocol.</li> </ul>"},{"location":"#architecture-overview","title":"Architecture Overview","text":"<p>Grizabella's power stems from its unique tri-layer architecture:</p> <ol> <li>Relational Layer (SQLite): Forms the foundation for structured data. It stores object metadata, schema definitions, and other relational information, ensuring data integrity and providing a solid base for other layers.</li> <li>Vector Layer (LanceDB): Handles high-dimensional vector embeddings. This layer is optimized for fast similarity searches, enabling semantic understanding and retrieval of unstructured or semi-structured data.</li> <li>Graph Layer (Kuzu): Manages complex relationships between data entities. This layer allows for sophisticated graph-based queries and analysis, uncovering insights from interconnected data.</li> </ol> <p>These three layers work in concert, managed by a central <code>DBManager</code>, to provide a holistic and flexible memory solution.</p> <p>This guide will walk you through installing Grizabella, getting started with its core functionalities, and leveraging its advanced features to build next-generation LLM-powered applications.</p>"},{"location":"core_concepts/","title":"Core Concepts in Grizabella","text":"<p>This document explains the fundamental concepts in Grizabella, providing a foundation for understanding how to define schemas, manage data, and utilize the system effectively.</p>"},{"location":"core_concepts/#database-instances","title":"Database Instances","text":"<p>A Grizabella database instance is a self-contained environment where your schema definitions and data are stored. When you initialize the Grizabella client, you specify which database instance to connect to.</p> <ul> <li>Default Path: If you initialize <code>Grizabella()</code> without specifying a <code>db_name_or_path</code>, it will connect to or create a database named \"default\" in a standard Grizabella data directory (e.g., <code>~/.grizabella/databases/default</code>).</li> <li>Named Instances: You can use a simple string name like <code>\"my_project_db\"</code>. Grizabella will manage this database within its standard data directory (e.g., <code>~/.grizabella/databases/my_project_db</code>).</li> <li>Custom Paths: You can provide a full file system path (as a string or <code>pathlib.Path</code> object) to a directory where you want the database to be stored. This gives you full control over the location of your database files.</li> </ul> <pre><code>from grizabella import Grizabella\nfrom pathlib import Path\n\n# Connect to the default database instance\ndb_default = Grizabella()\n\n# Connect to a named database instance\ndb_named = Grizabella(db_name_or_path=\"my_project_db\")\n\n# Connect to a database at a custom path\ndb_custom_path = Grizabella(db_name_or_path=Path(\"/opt/grizabella_data/my_app_db\"))\n</code></pre>"},{"location":"core_concepts/#schema-definitions","title":"Schema Definitions","text":"<p>The schema in Grizabella defines the structure of your data. It consists of Object Types, Embedding Definitions, and Relation Types.</p>"},{"location":"core_concepts/#object-types","title":"Object Types","text":"<p>Object Types define the blueprint for the kinds of entities you want to store in Grizabella. Think of them as analogous to tables in a relational database or node labels in a graph database. Each Object Type has a name and a set of properties.</p> <p>Structure:</p> <ul> <li><code>name</code>: A unique name for the object type (e.g., \"Document\", \"User\"). Conventionally, PascalCase is used.</li> <li><code>description</code>: An optional human-readable description.</li> <li><code>properties</code>: A list of <code>PropertyDefinition</code> objects that define the attributes of this object type.</li> </ul> <p>Properties (<code>PropertyDefinition</code>):</p> <ul> <li><code>name</code>: The name of the property (e.g., \"title\", \"email\", \"creation_date\").</li> <li><code>data_type</code>: The data type of the property, chosen from <code>PropertyDataType</code> enum (e.g., <code>TEXT</code>, <code>INTEGER</code>, <code>FLOAT</code>, <code>BOOLEAN</code>, <code>DATETIME</code>, <code>BLOB</code>, <code>JSON</code>, <code>UUID</code>).</li> <li><code>is_primary_key</code>: (Optional, boolean) Indicates if this property serves as a domain-specific primary key. An <code>ObjectInstance</code> always has a system-generated unique <code>id</code> (UUID). This flag is for an additional, user-defined primary key. An <code>ObjectTypeDefinition</code> can have at most one such primary key. Defaults to <code>False</code>.</li> <li><code>is_nullable</code>: (boolean) Can this property have a null value? Defaults to <code>True</code>.</li> <li><code>is_indexed</code>: (boolean) Should this property be indexed by underlying databases to speed up queries? Defaults to <code>False</code>.</li> <li><code>is_unique</code>: (boolean) Must values for this property be unique across all instances of this Object Type? Defaults to <code>False</code>.</li> <li><code>description</code>: An optional description of the property.</li> </ul> <p>Conceptual Pydantic Model Example for <code>ObjectTypeDefinition</code>:</p> <pre><code>from typing import List, Optional\nfrom pydantic import BaseModel, Field\nfrom enum import Enum\n\nclass PropertyDataType(str, Enum):\n    TEXT = \"TEXT\"\n    INTEGER = \"INTEGER\"\n    # ... other types\n\nclass PropertyDefinition(BaseModel):\n    name: str\n    data_type: PropertyDataType\n    is_primary_key: bool = False\n    is_nullable: bool = True\n    is_indexed: bool = False\n    is_unique: bool = False\n    description: Optional[str] = None\n\nclass ObjectTypeDefinition(BaseModel):\n    name: str = Field(description=\"Unique name for the object type. Convention: PascalCase.\")\n    description: Optional[str] = Field(default=None, description=\"Optional description.\")\n    properties: List[PropertyDefinition] = Field(description=\"List of properties.\")\n\n# Example Usage (conceptual, actual usage via Grizabella client)\n# book_type = ObjectTypeDefinition(\n#     name=\"Book\",\n#     description=\"Represents a book in the library.\",\n#     properties=[\n#         PropertyDefinition(name=\"title\", data_type=PropertyDataType.TEXT, is_indexed=True),\n#         PropertyDefinition(name=\"isbn\", data_type=PropertyDataType.TEXT, is_primary_key=True, is_unique=True),\n#         PropertyDefinition(name=\"published_year\", data_type=PropertyDataType.INTEGER),\n#         PropertyDefinition(name=\"pages\", data_type=PropertyDataType.INTEGER, is_nullable=True),\n#     ]\n# )\n</code></pre> <p>(The actual <code>ObjectTypeDefinition</code> and <code>PropertyDefinition</code> models are available in <code>grizabella.core.models</code>)</p>"},{"location":"core_concepts/#embedding-definitions","title":"Embedding Definitions","text":"<p>Embedding Definitions specify how vector embeddings should be generated and stored for objects of a particular type. Embeddings are numerical representations of data (often text) that capture semantic meaning, enabling similarity searches.</p> <p>Purpose:</p> <ul> <li>To configure the automatic generation of vector embeddings from specific properties of your objects.</li> <li>To link an object type and one ofits properties to a specific embedding model.</li> <li>To enable semantic search capabilities (e.g., \"find documents similar to this text\").</li> </ul> <p>Structure (<code>EmbeddingDefinition</code>):</p> <ul> <li><code>name</code>: A unique name for this embedding configuration (e.g., \"product_description_embedding\"). Conventionally, snake_case.</li> <li><code>object_type_name</code>: The name of the <code>ObjectTypeDefinition</code> this embedding applies to (e.g., \"Product\").</li> <li><code>source_property_name</code>: The name of the property within the <code>object_type_name</code> whose content will be used to generate the embedding (e.g., \"description\"). This property should typically be of <code>PropertyDataType.TEXT</code>.</li> <li><code>embedding_model</code>: An identifier for the embedding model to be used (e.g., a Hugging Face model name like \"sentence-transformers/all-MiniLM-L6-v2\").</li> <li><code>dimensions</code>: (Optional, integer) The expected dimensionality of the embedding vector. If <code>None</code>, the system may attempt to infer it from the model.</li> <li><code>description</code>: An optional human-readable description.</li> </ul> <p>Example (conceptual):</p> <pre><code># Conceptual Pydantic Model for EmbeddingDefinition\n# from pydantic import BaseModel, Field\n# from typing import Optional\n\n# class EmbeddingDefinition(BaseModel):\n#     name: str\n#     object_type_name: str\n#     source_property_name: str\n#     embedding_model: str\n#     dimensions: Optional[int] = None\n#     description: Optional[str] = None\n\n# Example Usage (conceptual, actual usage via Grizabella client)\n# article_content_embedding = EmbeddingDefinition(\n#     name=\"article_content_embedding_v1\",\n#     object_type_name=\"Article\", # Assumes an ObjectType \"Article\" exists\n#     source_property_name=\"body_text\", # Assumes \"Article\" has a \"body_text\" property\n#     embedding_model=\"sentence-transformers/all-MiniLM-L6-v2\",\n#     dimensions=384,\n#     description=\"Embeds the main body text of articles for similarity search.\"\n# )\n</code></pre> <p>(The actual <code>EmbeddingDefinition</code> model is available in <code>grizabella.core.models</code>)</p>"},{"location":"core_concepts/#relation-types","title":"Relation Types","text":"<p>Relation Types define the schema for relationships between <code>ObjectInstance</code>s. They are analogous to edge labels in a graph database or foreign key relationships (with potential properties on the join table) in a relational database.</p> <p>Structure (<code>RelationTypeDefinition</code>):</p> <ul> <li><code>name</code>: A unique name for the relation type (e.g., \"WROTE\", \"CONTAINS_ITEM\"). Conventionally, UPPER_SNAKE_CASE.</li> <li><code>description</code>: An optional human-readable description.</li> <li><code>source_object_type_names</code>: A list of <code>ObjectTypeDefinition</code> names that are allowed as the source (or \"from\" side) of this relation.</li> <li><code>target_object_type_names</code>: A list of <code>ObjectTypeDefinition</code> names that are allowed as the target (or \"to\" side) of this relation.</li> <li><code>properties</code>: (Optional) A list of <code>PropertyDefinition</code> objects that define attributes belonging to the relation itself (often called edge properties). Defaults to an empty list.</li> </ul> <p>Example (conceptual):</p> <pre><code># Conceptual Pydantic Model for RelationTypeDefinition\n# from pydantic import BaseModel, Field\n# from typing import List, Optional\n# from .object_types import PropertyDefinition # Assuming PropertyDefinition is defined\n\n# class RelationTypeDefinition(BaseModel):\n#     name: str\n#     description: Optional[str] = None\n#     source_object_type_names: List[str]\n#     target_object_type_names: List[str]\n#     properties: List[PropertyDefinition] = Field(default_factory=list)\n\n# Example Usage (conceptual, actual usage via Grizabella client)\n# authored_by_relation = RelationTypeDefinition(\n#     name=\"AUTHORED_BY\",\n#     description=\"Indicates that a Book was written by an Author.\",\n#     source_object_type_names=[\"Book\"], # Assumes \"Book\" ObjectType exists\n#     target_object_type_names=[\"Author\"], # Assumes \"Author\" ObjectType exists\n#     properties=[\n#         PropertyDefinition(name=\"role\", data_type=PropertyDataType.TEXT, is_nullable=True) # e.g., \"Primary Author\", \"Editor\"\n#     ]\n# )\n</code></pre> <p>(The actual <code>RelationTypeDefinition</code> model is available in <code>grizabella.core.models</code>)</p>"},{"location":"core_concepts/#data-instances","title":"Data Instances","text":"<p>Data instances are the actual pieces of data you store in Grizabella. They conform to the schemas defined by Object Types, Embedding Definitions, and Relation Types.</p> <ul> <li>Objects (<code>ObjectInstance</code>): A concrete instance of an <code>ObjectTypeDefinition</code>. It has a unique system-generated <code>id</code> (UUID), an <code>object_type_name</code> linking it to its definition, and a <code>properties</code> dictionary holding the actual data for the fields defined in the <code>ObjectTypeDefinition</code>.</li> <li> <p>Example: An <code>ObjectInstance</code> of type \"Book\" might have <code>properties: {\"title\": \"The Great Gatsby\", \"isbn\": \"9780743273565\", \"published_year\": 1925}</code>.</p> </li> <li> <p>Relations (<code>RelationInstance</code>): A concrete instance of a <code>RelationTypeDefinition</code>. It links two <code>ObjectInstance</code>s (a source and a target) and has a <code>relation_type_name</code>. It also has a unique system-generated <code>id</code> (UUID) and can have its own <code>properties</code> if defined in the <code>RelationTypeDefinition</code>.</p> </li> <li> <p>Example: A <code>RelationInstance</code> of type \"AUTHORED_BY\" might link a \"Book\" object (source) to an \"Author\" object (target), with <code>properties: {\"role\": \"Primary Author\"}</code>.</p> </li> <li> <p>Embeddings (<code>EmbeddingInstance</code>): A concrete instance of an embedding. It stores the vector generated from a specific property of an <code>ObjectInstance</code> according to an <code>EmbeddingDefinition</code>. It includes the <code>object_instance_id</code> it belongs to, the <code>embedding_definition_name</code> used, the <code>vector</code> itself (a list of floats), and optionally a <code>source_text_preview</code>.</p> </li> <li>Example: An <code>EmbeddingInstance</code> linked to the \"Book\" object for \"The Great Gatsby\", generated using \"article_content_embedding_v1\" (if applicable), would contain the actual vector.</li> </ul>"},{"location":"core_concepts/#memory-metadata-memoryinstance","title":"Memory Metadata (<code>MemoryInstance</code>)","text":"<p>All core data instances in Grizabella (<code>ObjectInstance</code>, <code>RelationInstance</code>, <code>EmbeddingInstance</code>) inherit from a base model called <code>MemoryInstance</code>. This base model provides common metadata fields crucial for managing and understanding the data:</p> <ul> <li><code>id</code> (UUID): A universally unique identifier automatically generated for every instance upon creation. This is the primary way to uniquely identify any piece of data within Grizabella.</li> <li><code>weight</code> (Decimal, 0-10): A numerical value representing the importance, relevance, or confidence associated with the data instance. It defaults to <code>1.0</code>. This can be used for:</li> <li>Ranking search results.</li> <li>Prioritizing data during processing or eviction.</li> <li>Implementing decay functions where older or less relevant data might have its weight reduced.</li> <li><code>upsert_date</code> (datetime): A timestamp (in UTC) indicating when the instance was last created or updated (upserted). This is automatically set by the system. It's useful for:</li> <li>Tracking data freshness.</li> <li>Implementing time-based queries or filtering.</li> <li>Auditing changes.</li> </ul> <p>These metadata fields provide a consistent way to manage and query your data's lifecycle and significance within Grizabella.</p>"},{"location":"getting_started/","title":"Getting Started with Grizabella","text":"<p>This guide will help you take your first steps with Grizabella, whether you're using it as a Python library, interacting with the PySide6 UI, or connecting via the MCP server.</p>"},{"location":"getting_started/#using-grizabella-as-a-library-python-api","title":"Using Grizabella as a Library (Python API)","text":"<p>The Grizabella Python API provides a powerful way to integrate its multi-layer database capabilities into your applications.</p> <p>Here's a short example demonstrating basic operations:</p> <pre><code>from grizabella.api import Grizabella\nfrom grizabella.core.models import ObjectTypeDefinition, PropertyDefinition, DataType\n\n# 1. Initialize and connect to Grizabella\n# This will use the default database path (~/.grizabella/default_grizabella.db)\n# or create it if it doesn't exist.\n# For more robust error handling, wrap in try...finally or use a 'with' statement.\n\nprint(\"Initializing Grizabella client...\")\nclient = Grizabella() # You can specify a db_path: client = Grizabella(db_path=\"/path/to/your/grizabella.db\")\n\ntry:\n    print(\"Connecting to the database...\")\n    client.connect()\n    print(\"Successfully connected.\")\n\n    # 2. Define a simple Object Type\n    print(\"Defining 'Note' object type...\")\n    note_type_def = ObjectTypeDefinition(\n        name=\"Note\",\n        description=\"A simple text note.\",\n        properties=[\n            PropertyDefinition(name=\"title\", data_type=DataType.STRING, is_required=True),\n            PropertyDefinition(name=\"content\", data_type=DataType.TEXT),\n        ]\n    )\n    client.create_object_type(note_type_def)\n    print(f\"Object type '{note_type_def.name}' created.\")\n\n    # 3. Create an Object Instance of this type\n    print(\"Creating an instance of 'Note'...\")\n    note_instance_data = {\n        \"title\": \"My First Note\",\n        \"content\": \"This is a test note created using the Grizabella Python API.\"\n    }\n    # The create_object_instance method returns the created object with its assigned ID\n    created_note = client.create_object_instance(object_type_name=\"Note\", data=note_instance_data)\n    print(f\"Created note with ID: {created_note.id}\")\n    print(f\"  Title: {created_note.data['title']}\")\n    print(f\"  Content: {created_note.data['content']}\")\n\n\n    # 4. Retrieve the object\n    print(f\"Retrieving note with ID: {created_note.id}...\")\n    retrieved_note = client.get_object_instance(object_type_name=\"Note\", instance_id=created_note.id)\n\n    if retrieved_note:\n        print(\"Successfully retrieved note:\")\n        print(f\"  ID: {retrieved_note.id}\")\n        print(f\"  Type: {retrieved_note.object_type_name}\")\n        print(f\"  Title: {retrieved_note.data['title']}\")\n        print(f\"  Content: {retrieved_note.data['content']}\")\n        print(f\"  Created at: {retrieved_note.created_at}\")\n        print(f\"  Updated at: {retrieved_note.updated_at}\")\n    else:\n        print(f\"Could not retrieve note with ID: {created_note.id}\")\n\nfinally:\n    # 5. Close the connection\n    print(\"Closing the database connection...\")\n    client.close()\n    print(\"Connection closed.\")\n\n# Alternative using a 'with' statement for automatic connection management:\n#\n# with Grizabella() as client_with:\n#     # ... perform operations ...\n#     pass # Connection is automatically closed here\n</code></pre> <p>This snippet covers:</p> <ul> <li>Initializing the <code>Grizabella</code> client.</li> <li>Connecting to the database (which also handles schema migrations).</li> <li>Defining an <code>ObjectTypeDefinition</code> for a \"Note\".</li> <li>Creating an <code>ObjectInstance</code> of that \"Note\".</li> <li>Retrieving the created <code>ObjectInstance</code> by its ID.</li> <li>Closing the database connection.</li> </ul> <p>Explore the API documentation for more advanced features like creating relations, managing embeddings, and performing complex queries.</p>"},{"location":"getting_started/#using-the-pyside6-ui-brief-overview","title":"Using the PySide6 UI (Brief Overview)","text":"<p>The Grizabella PySide6 UI provides a graphical way to interact with your Grizabella databases.</p> <ol> <li> <p>Launch the UI:     If you installed Grizabella from source using Poetry, run:</p> <p><code>bash poetry run grizabella-ui</code></p> </li> <li> <p>Connection View:     Upon launching, you'll see the Connection View.</p> <ul> <li>Default Database: You can connect to the default Grizabella database (usually located at <code>~/.grizabella/default_grizabella.db</code>). If it doesn't exist, Grizabella will offer to create it for you.</li> <li>Specify Path: Alternatively, you can click \"Browse\" to select an existing Grizabella database file or choose a location for a new one.</li> <li>Click \"Connect\" to open the database.</li> </ul> </li> <li> <p>Basic Navigation (Post-Connection):     Once connected, the main window will appear.</p> <ul> <li>Schema Editor (Object Types / Relation Types): Navigate to the \"Object Types\" or \"Relation Types\" sections (often tabs or sidebar items) to define your data structures. You can create new types, add properties, and define their data types.</li> <li>Object Explorer / Relation Explorer: After defining your schemas, go to the \"Object Explorer\" or \"Relation Explorer\" to create instances of your object and relation types. You can fill in their properties and see them listed.</li> </ul> <p>This provides a very high-level overview. The UI offers more detailed views for managing embeddings, executing queries, and exploring data. Refer to the full UI guide for comprehensive instructions.</p> </li> </ol>"},{"location":"getting_started/#using-the-mcp-server-brief-overview","title":"Using the MCP Server (Brief Overview)","text":"<p>The Grizabella MCP (Model Context Protocol) server allows other applications or AI agents to interact with Grizabella programmatically over a network interface.</p> <ol> <li> <p>Launch the MCP Server:     If you installed Grizabella from source using Poetry, run:</p> <p><code>bash poetry run grizabella-mcp</code></p> <p>By default, the server will start (e.g., on <code>http://localhost:8000</code> - check the server startup logs for the exact address and port).</p> </li> <li> <p>Interacting with the MCP Server (Conceptual Example):     You can interact with the MCP server using any HTTP client, such as <code>curl</code> or a programmatic client in your preferred language. The exact tools and request formats will depend on the MCP tools exposed by Grizabella.</p> <p>Here's a conceptual example using <code>curl</code> to list available object types (assuming an MCP tool named <code>list_object_types</code> exists and the server is on <code>localhost:8000</code>):</p> <p>```bash</p> </li> </ol> <p>This section provides a starting point. As you delve deeper, consult the API reference, UI guides, and MCP server documentation for detailed information on all of Grizabella's capabilities.</p>"},{"location":"getting_started/#this-is-a-hypothetical-example-the-actual-tool-name-and-parameters-may-differ","title":"This is a hypothetical example. The actual tool name and parameters may differ.","text":"<p>curl -X POST http://localhost:8000/mcp \\      -H \"Content-Type: application/json\" \\      -d '{            \"tool_name\": \"list_object_types\",            \"arguments\": {}          }' ```</p> <p>The server would respond with a JSON payload containing the list of object types or an error if the request is invalid or the tool doesn't exist.</p> <p>Note: The specific MCP tools available and their request/response schemas are defined within the Grizabella MCP server implementation. You'll need to refer to the Grizabella MCP documentation (or inspect its capabilities if it provides a discovery mechanism) for actual tool names and argument structures. A common basic tool might be to get schema information or list instances of a certain type.</p>"},{"location":"installation/","title":"Installation","text":"<p>This guide provides instructions for installing Grizabella in different ways, depending on your needs.</p>"},{"location":"installation/#as-a-library","title":"As a Library","text":""},{"location":"installation/#using-pip-future-once-published","title":"Using pip (Future - Once Published)","text":"<p>Once Grizabella is published to the Python Package Index (PyPI), you will be able to install it easily using pip:</p> <pre><code>pip install grizabella\n</code></pre> <p>Stay tuned for updates on our official PyPI release!</p>"},{"location":"installation/#from-source-for-development-or-current-use","title":"From Source (for Development or Current Use)","text":"<p>If you want to use the latest development version or contribute to Grizabella, you can install it from source:</p> <ol> <li> <p>Clone the repository:</p> <p><code>bash git clone https://github.com/pwilkin/grizabella.git cd grizabella</code></p> </li> <li> <p>Install using Poetry:     We use Poetry for dependency management and packaging. Ensure you have Poetry installed.</p> <p><code>bash poetry install</code></p> <p>This command will create a virtual environment (if one isn't active) and install all necessary dependencies.</p> </li> </ol>"},{"location":"installation/#standalone-pyside6-application","title":"Standalone PySide6 Application","text":"<p>Grizabella includes a PySide6-based graphical user interface for managing your data.</p>"},{"location":"installation/#running-from-source","title":"Running from Source","text":"<p>After installing from source using Poetry (see above), you can run the UI application with:</p> <pre><code>poetry run grizabella-ui\n</code></pre>"},{"location":"installation/#system-dependencies","title":"System Dependencies","text":""},{"location":"installation/#python-version","title":"Python Version","text":"<p>Grizabella requires Python version &gt;=3.10 and &lt;3.14. Please ensure you have a compatible Python version installed.</p>"},{"location":"installation/#arrow-c-libraries-for-lancedb","title":"Arrow C++ Libraries (for LanceDB)","text":"<p>The <code>lancedb</code> library, used by Grizabella for vector storage, depends on the Apache Arrow C++ libraries. You'll need to install these on your system if they are not already present.</p> <ul> <li> <p>For Debian/Ubuntu:</p> <p>```bash sudo apt update sudo apt install -y -V libarrow-dev</p> </li> <li> <p>For macOS (using Homebrew):</p> <p><code>bash brew install apache-arrow</code></p> </li> <li> <p>For other systems or Conda:     Please refer to the official Apache Arrow installation guide: https://arrow.apache.org/install/</p> <p>If you are using Conda, you might be able to install Arrow via:</p> <p><code>bash conda install -c conda-forge pyarrow</code></p> <p>Ensure that the <code>pyarrow</code> version is compatible with <code>lancedb</code>.</p> </li> </ul>"},{"location":"installation/#you-might-also-need","title":"You might also need:","text":""},{"location":"installation/#sudo-apt-install-y-v-libarrow-python-dev","title":"sudo apt install -y -V libarrow-python-dev","text":"<p>```</p>"},{"location":"installation/#verifying-installation","title":"Verifying Installation","text":""},{"location":"installation/#library","title":"Library","text":"<p>To verify that the Grizabella library is installed correctly, open a Python interpreter and try importing it:</p> <pre><code>try:\n    from grizabella.api import Grizabella\n    print(\"Grizabella library imported successfully!\")\nexcept ImportError:\n    print(\"Failed to import Grizabella library.\")\n</code></pre>"},{"location":"installation/#pyside6-ui","title":"PySide6 UI","text":"<p>Launch the UI as described above:</p> <pre><code>poetry run grizabella-ui\n</code></pre> <p>If the application window appears, the UI component is likely installed correctly. You can try connecting to a database (or creating a new one) to further verify.</p>"},{"location":"mcp_server_api_guide/","title":"Grizabella MCP Server API Guide","text":"<p>This guide provides detailed information about the Grizabella Model Context Protocol (MCP) server API. The MCP server exposes Grizabella's core functionalities as tools that can be accessed remotely.</p>"},{"location":"mcp_server_api_guide/#launching-the-mcp-server","title":"Launching the MCP Server","text":"<p>To launch the Grizabella MCP server, navigate to the root directory of the Grizabella project and run the following command:</p> <pre><code>poetry run grizabella-mcp\n</code></pre> <p>This command starts the MCP server, making its tools available for interaction. The server typically runs using <code>fastmcp</code>, which might be based on FastAPI/Starlette.</p>"},{"location":"mcp_server_api_guide/#database-configuration","title":"Database Configuration","text":"<p>The Grizabella MCP server requires a database to store its data. The path to this database can be configured using the <code>GRIZABELLA_DB_PATH</code> environment variable.</p> <ul> <li>Environment Variable: <code>GRIZABELLA_DB_PATH</code></li> <li>Default Value: If the environment variable is not set, the server will use <code>grizabella_mcp_db</code> (relative to where the server is run) as the database path.</li> </ul> <p>Example:</p> <p>To set a custom database path (e.g., <code>/opt/grizabella_data/my_db</code>):</p> <pre><code>export GRIZABELLA_DB_PATH=\"/opt/grizabella_data/my_db\"\npoetry run grizabella-mcp\n</code></pre> <p>If the specified database file or directory doesn't exist, Grizabella will attempt to create it.</p>"},{"location":"mcp_server_api_guide/#mcp-tools-operations","title":"MCP Tools / Operations","text":"<p>The Grizabella MCP server exposes several tools, each corresponding to an operation on the Grizabella data store. These tools are defined in <code>grizabella.mcp.server</code> and map to methods of the <code>Grizabella</code> API client.</p> <p>Requests to these tools are typically JSON-RPC style, where the MCP client sends a JSON payload specifying the tool name and its arguments. Responses are also in JSON format.</p>"},{"location":"mcp_server_api_guide/#error-handling","title":"Error Handling","text":"<p>Errors are generally reported as a JSON response containing an error message. This might be a standard FastAPI/FastMCP error structure, often including a \"detail\" field or an \"error\" field. For Grizabella-specific errors, the message will typically be prefixed with \"Grizabella API Error:\".</p>"},{"location":"mcp_server_api_guide/#schema-management","title":"Schema Management","text":""},{"location":"mcp_server_api_guide/#1-create_object_type","title":"1. <code>create_object_type</code>","text":"<ul> <li>Description: Creates a new object type definition (e.g., a table schema or a node type in a graph).</li> <li>Input Parameters (JSON):</li> <li><code>object_type_def</code> (object, required): The definition of the object type. This structure is based on the <code>ObjectTypeDefinition</code> Pydantic model.<ul> <li><code>name</code> (string, required): Unique name for the object type (e.g., \"Document\", \"Person\"). Convention: PascalCase.</li> <li><code>description</code> (string, optional): Optional description of the object type.</li> <li><code>properties</code> (array, required): List of property definitions for this object type. Each property definition is an object:</li> <li><code>name</code> (string, required): Name of the property (e.g., \"title\", \"age\").</li> <li><code>data_type</code> (string, required): Data type of the property. Must be one of the values from <code>PropertyDataType</code> (e.g., \"TEXT\", \"INTEGER\", \"FLOAT\", \"BOOLEAN\", \"DATETIME\", \"BLOB\", \"JSON\", \"UUID\").</li> <li><code>is_primary_key</code> (boolean, optional, default: <code>false</code>): Is this property a primary key?</li> <li><code>is_nullable</code> (boolean, optional, default: <code>true</code>): Can this property be null?</li> <li><code>is_indexed</code> (boolean, optional, default: <code>false</code>): Should this property be indexed?</li> <li><code>is_unique</code> (boolean, optional, default: <code>false</code>): Does this property require unique values?</li> <li><code>description</code> (string, optional): Optional description of the property.</li> </ul> </li> <li> <p>Example Input (JSON):</p> <p><code>json {     \"object_type_def\": {         \"name\": \"Document\",         \"description\": \"Represents a text document.\",         \"properties\": [             {                 \"name\": \"title\",                 \"data_type\": \"TEXT\",                 \"is_indexed\": true             },             {                 \"name\": \"content\",                 \"data_type\": \"TEXT\"             },             {                 \"name\": \"published_date\",                 \"data_type\": \"DATETIME\",                 \"is_nullable\": true             }         ]     } }</code></p> </li> <li> <p>Output Parameters (JSON):</p> </li> <li> <p>Returns <code>null</code> or a success message upon successful creation.</p> </li> <li> <p>Example Output (JSON):</p> <p><code>json null</code></p> <p>(Or potentially a success object depending on FastMCP's conventions for void returns)</p> </li> </ul>"},{"location":"mcp_server_api_guide/#2-get_object_type","title":"2. <code>get_object_type</code>","text":"<ul> <li>Description: Retrieves the definition of a specific object type.</li> <li>Input Parameters (JSON):</li> <li><code>type_name</code> (string, required): The name of the object type to retrieve.</li> <li> <p>Example Input (JSON):</p> <p><code>json {     \"type_name\": \"Document\" }</code></p> </li> <li> <p>Output Parameters (JSON):</p> </li> <li> <p>Returns an <code>ObjectTypeDefinition</code> object if found, or <code>null</code> if not found. The structure is the same as the <code>object_type_def</code> input for <code>create_object_type</code>.</p> </li> <li> <p>Example Output (JSON):</p> <p><code>json {     \"name\": \"Document\",     \"description\": \"Represents a text document.\",     \"properties\": [         {             \"name\": \"title\",             \"data_type\": \"TEXT\",             \"is_primary_key\": false,             \"is_nullable\": true,             \"is_indexed\": true,             \"is_unique\": false,             \"description\": null         },         {             \"name\": \"content\",             \"data_type\": \"TEXT\",             \"is_primary_key\": false,             \"is_nullable\": true,             \"is_indexed\": false,             \"is_unique\": false,             \"description\": null         },         {             \"name\": \"published_date\",             \"data_type\": \"DATETIME\",             \"is_primary_key\": false,             \"is_nullable\": true,             \"is_indexed\": false,             \"is_unique\": false,             \"description\": null         }     ] }</code></p> </li> </ul>"},{"location":"mcp_server_api_guide/#3-delete_object_type","title":"3. <code>delete_object_type</code>","text":"<ul> <li>Description: Deletes an object type definition.</li> <li>Input Parameters (JSON):</li> <li><code>type_name</code> (string, required): The name of the object type to delete.</li> <li> <p>Example Input (JSON):</p> <p><code>json {     \"type_name\": \"Document\" }</code></p> </li> <li> <p>Output Parameters (JSON):</p> </li> <li> <p>Returns <code>null</code> or a success message upon successful deletion.</p> </li> <li> <p>Example Output (JSON):</p> <p><code>json null</code></p> </li> </ul>"},{"location":"mcp_server_api_guide/#4-create_relation_type","title":"4. <code>create_relation_type</code>","text":"<ul> <li>Description: Creates a new relation type definition.</li> <li>Input Parameters (JSON):</li> <li><code>relation_type_def</code> (object, required): The definition of the relation type. This structure is based on the <code>RelationTypeDefinition</code> Pydantic model.<ul> <li><code>name</code> (string, required): Unique name for the relation type (e.g., \"HAS_AUTHOR\"). Convention: UPPER_SNAKE_CASE.</li> <li><code>description</code> (string, optional): Optional description of the relation type.</li> <li><code>source_object_type_names</code> (array of strings, required): List of names of allowed source <code>ObjectTypeDefinition</code>s.</li> <li><code>target_object_type_names</code> (array of strings, required): List of names of allowed target <code>ObjectTypeDefinition</code>s.</li> <li><code>properties</code> (array, optional, default: <code>[]</code>): List of property definitions for the relation itself (edge properties). Structure is the same as for <code>ObjectTypeDefinition</code> properties.</li> </ul> </li> <li> <p>Example Input (JSON):</p> <p><code>json {     \"relation_type_def\": {         \"name\": \"AUTHORED_BY\",         \"description\": \"Indicates authorship of a document by a person.\",         \"source_object_type_names\": [\"Document\"],         \"target_object_type_names\": [\"Person\"],         \"properties\": [             {                 \"name\": \"role\",                 \"data_type\": \"TEXT\",                 \"is_nullable\": true             }         ]     } }</code></p> </li> <li> <p>Output Parameters (JSON):</p> </li> <li> <p>Returns <code>null</code> or a success message.</p> </li> <li> <p>Example Output (JSON):</p> <p><code>json null</code></p> </li> </ul>"},{"location":"mcp_server_api_guide/#5-get_relation_type","title":"5. <code>get_relation_type</code>","text":"<ul> <li>Description: Retrieves the definition of a specific relation type.</li> <li>Input Parameters (JSON):</li> <li><code>type_name</code> (string, required): The name of the relation type to retrieve.</li> <li> <p>Example Input (JSON):</p> <p><code>json {     \"type_name\": \"AUTHORED_BY\" }</code></p> </li> <li> <p>Output Parameters (JSON):</p> </li> <li> <p>Returns a <code>RelationTypeDefinition</code> object if found, or <code>null</code> if not found. The structure is the same as the <code>relation_type_def</code> input for <code>create_relation_type</code>.</p> </li> <li> <p>Example Output (JSON):</p> <p><code>json {     \"name\": \"AUTHORED_BY\",     \"description\": \"Indicates authorship of a document by a person.\",     \"source_object_type_names\": [\"Document\"],     \"target_object_type_names\": [\"Person\"],     \"properties\": [         {             \"name\": \"role\",             \"data_type\": \"TEXT\",             \"is_primary_key\": false,             \"is_nullable\": true,             \"is_indexed\": false,             \"is_unique\": false,             \"description\": null         }     ] }</code></p> </li> </ul>"},{"location":"mcp_server_api_guide/#6-delete_relation_type","title":"6. <code>delete_relation_type</code>","text":"<ul> <li>Description: Deletes a relation type definition.</li> <li>Input Parameters (JSON):</li> <li><code>type_name</code> (string, required): The name of the relation type to delete.</li> <li> <p>Example Input (JSON):</p> <p><code>json {     \"type_name\": \"AUTHORED_BY\" }</code></p> </li> <li> <p>Output Parameters (JSON):</p> </li> <li> <p>Returns <code>null</code> or a success message.</p> </li> <li> <p>Example Output (JSON):</p> <p><code>json null</code></p> </li> </ul>"},{"location":"mcp_server_api_guide/#object-instance-management","title":"Object Instance Management","text":""},{"location":"mcp_server_api_guide/#7-upsert_object","title":"7. <code>upsert_object</code>","text":"<ul> <li>Description: Creates a new object instance or updates an existing one if an object with the same ID already exists.</li> <li>Input Parameters (JSON):</li> <li><code>obj</code> (object, required): The object instance to create or update. This structure is based on the <code>ObjectInstance</code> Pydantic model.<ul> <li><code>id</code> (string, optional, UUID format): Unique identifier for the object. If not provided, a new UUID will be generated. If provided and an object with this ID exists, it will be updated.</li> <li><code>weight</code> (number, optional, default: <code>1.0</code>): A decimal value (0-10) for ranking/relevance.</li> <li><code>upsert_date</code> (string, optional, ISO 8601 datetime format): Timestamp of last update. Automatically set if not provided.</li> <li><code>object_type_name</code> (string, required): Name of the <code>ObjectTypeDefinition</code> this instance conforms to.</li> <li><code>properties</code> (object, required): Key-value pairs representing the actual data for the instance, where keys are property names.</li> </ul> </li> <li> <p>Example Input (JSON):</p> <p><code>json {     \"obj\": {         \"object_type_name\": \"Document\",         \"properties\": {             \"title\": \"My First Document\",             \"content\": \"This is the content of my first document.\",             \"published_date\": \"2024-01-15T10:00:00Z\"         }     } }</code></p> </li> <li> <p>Output Parameters (JSON):</p> </li> <li> <p>Returns the created or updated <code>ObjectInstance</code> object, including its <code>id</code> and <code>upsert_date</code>.</p> </li> <li> <p>Example Output (JSON):</p> <p><code>json {     \"id\": \"a1b2c3d4-e5f6-7890-1234-567890abcdef\",     \"weight\": 1.0,     \"upsert_date\": \"2024-06-04T19:55:00.123456Z\",     \"object_type_name\": \"Document\",     \"properties\": {         \"title\": \"My First Document\",         \"content\": \"This is the content of my first document.\",         \"published_date\": \"2024-01-15T10:00:00Z\"     } }</code></p> </li> </ul>"},{"location":"mcp_server_api_guide/#8-get_object_by_id","title":"8. <code>get_object_by_id</code>","text":"<ul> <li>Description: Retrieves a specific object instance by its ID and type name.</li> <li>Input Parameters (JSON):</li> <li><code>object_id</code> (string, required, UUID format): The ID of the object to retrieve.</li> <li><code>type_name</code> (string, required): The name of the object type.</li> <li> <p>Example Input (JSON):</p> <p><code>json {     \"object_id\": \"a1b2c3d4-e5f6-7890-1234-567890abcdef\",     \"type_name\": \"Document\" }</code></p> </li> <li> <p>Output Parameters (JSON):</p> </li> <li> <p>Returns the <code>ObjectInstance</code> object if found, or <code>null</code> if not found.</p> </li> <li> <p>Example Output (JSON): (Same structure as <code>upsert_object</code> output)</p> </li> </ul>"},{"location":"mcp_server_api_guide/#9-delete_object","title":"9. <code>delete_object</code>","text":"<ul> <li>Description: Deletes an object instance by its ID and type name.</li> <li>Input Parameters (JSON):</li> <li><code>object_id</code> (string, required, UUID format): The ID of the object to delete.</li> <li><code>type_name</code> (string, required): The name of the object type.</li> <li> <p>Example Input (JSON):</p> <p><code>json {     \"object_id\": \"a1b2c3d4-e5f6-7890-1234-567890abcdef\",     \"type_name\": \"Document\" }</code></p> </li> <li> <p>Output Parameters (JSON):</p> </li> <li> <p>Returns <code>true</code> if deletion was successful, <code>false</code> otherwise (e.g., if the object was not found).</p> </li> <li> <p>Example Output (JSON):</p> <p><code>json true</code></p> </li> </ul>"},{"location":"mcp_server_api_guide/#10-find_objects","title":"10. <code>find_objects</code>","text":"<ul> <li>Description: Finds object instances of a given type, optionally matching filter criteria.</li> <li>Input Parameters (JSON):</li> <li><code>type_name</code> (string, required): The name of the object type to search for.</li> <li><code>filter_criteria</code> (object, optional): A dictionary of property names to values for exact matching.</li> <li><code>limit</code> (integer, optional): Maximum number of objects to return.</li> <li> <p>Example Input (JSON):</p> <p><code>json {     \"type_name\": \"Document\",     \"filter_criteria\": {         \"author_id\": \"person_xyz\"     },     \"limit\": 10 }</code></p> </li> <li> <p>Output Parameters (JSON):</p> </li> <li> <p>Returns a list of <code>ObjectInstance</code> objects that match the criteria.</p> </li> <li> <p>Example Output (JSON):</p> <p><code>json [     {         \"id\": \"doc1-uuid\",         \"weight\": 1.0,         \"upsert_date\": \"2024-06-04T20:10:00Z\",         \"object_type_name\": \"Document\",         \"properties\": { \"title\": \"Doc One\", \"author_id\": \"person_xyz\" }     },     {         \"id\": \"doc2-uuid\",         \"weight\": 1.0,         \"upsert_date\": \"2024-06-04T20:11:00Z\",         \"object_type_name\": \"Document\",         \"properties\": { \"title\": \"Doc Two\", \"author_id\": \"person_xyz\" }     } ]</code></p> </li> </ul>"},{"location":"mcp_server_api_guide/#relation-instance-management","title":"Relation Instance Management","text":""},{"location":"mcp_server_api_guide/#11-add_relation","title":"11. <code>add_relation</code>","text":"<ul> <li>Description: Adds a new relation instance between two objects.</li> <li>Input Parameters (JSON):</li> <li><code>relation</code> (object, required): The relation instance to add. This structure is based on the <code>RelationInstance</code> Pydantic model.<ul> <li><code>id</code> (string, optional, UUID format): Unique ID for the relation. Auto-generated if not provided.</li> <li><code>weight</code> (number, optional, default: <code>1.0</code>): Relevance weight.</li> <li><code>upsert_date</code> (string, optional, ISO 8601 datetime): Auto-set if not provided.</li> <li><code>relation_type_name</code> (string, required): Name of the <code>RelationTypeDefinition</code>.</li> <li><code>source_object_instance_id</code> (string, required, UUID format): ID of the source object.</li> <li><code>target_object_instance_id</code> (string, required, UUID format): ID of the target object.</li> <li><code>properties</code> (object, optional, default: <code>{}</code>): Key-value pairs for relation properties.</li> </ul> </li> <li> <p>Example Input (JSON):</p> <p><code>json {     \"relation\": {         \"relation_type_name\": \"AUTHORED_BY\",         \"source_object_instance_id\": \"doc1-uuid\",         \"target_object_instance_id\": \"person_xyz-uuid\",         \"properties\": {             \"role\": \"Primary Author\"         }     } }</code></p> </li> <li> <p>Output Parameters (JSON):</p> </li> <li> <p>Returns the created <code>RelationInstance</code> object.</p> </li> <li> <p>Example Output (JSON):</p> <p><code>json {     \"id\": \"rel1-uuid\",     \"weight\": 1.0,     \"upsert_date\": \"2024-06-04T20:15:00Z\",     \"relation_type_name\": \"AUTHORED_BY\",     \"source_object_instance_id\": \"doc1-uuid\",     \"target_object_instance_id\": \"person_xyz-uuid\",     \"properties\": {         \"role\": \"Primary Author\"     } }</code></p> </li> </ul>"},{"location":"mcp_server_api_guide/#12-get_relation","title":"12. <code>get_relation</code>","text":"<ul> <li>Description: Retrieves a specific relation instance between two objects of a given relation type.</li> <li>Input Parameters (JSON):</li> <li><code>from_object_id</code> (string, required, UUID format): ID of the source object.</li> <li><code>to_object_id</code> (string, required, UUID format): ID of the target object.</li> <li><code>relation_type_name</code> (string, required): Name of the relation type.</li> <li> <p>Example Input (JSON):</p> <p><code>json {     \"from_object_id\": \"doc1-uuid\",     \"to_object_id\": \"person_xyz-uuid\",     \"relation_type_name\": \"AUTHORED_BY\" }</code></p> </li> <li> <p>Output Parameters (JSON):</p> </li> <li> <p>Returns the <code>RelationInstance</code> object if found, or <code>null</code>.</p> </li> <li> <p>Example Output (JSON): (Same structure as <code>add_relation</code> output)</p> </li> </ul>"},{"location":"mcp_server_api_guide/#13-delete_relation","title":"13. <code>delete_relation</code>","text":"<ul> <li>Description: Deletes a specific relation instance.</li> <li>Input Parameters (JSON):</li> <li><code>from_object_id</code> (string, required, UUID format): ID of the source object.</li> <li><code>to_object_id</code> (string, required, UUID format): ID of the target object.</li> <li><code>relation_type_name</code> (string, required): Name of the relation type.</li> <li> <p>Example Input (JSON):</p> <p><code>json {     \"from_object_id\": \"doc1-uuid\",     \"to_object_id\": \"person_xyz-uuid\",     \"relation_type_name\": \"AUTHORED_BY\" }</code></p> </li> <li> <p>Output Parameters (JSON):</p> </li> <li> <p>Returns <code>true</code> if deletion was successful, <code>false</code> otherwise.</p> </li> <li> <p>Example Output (JSON):</p> <p><code>json true</code></p> </li> </ul>"},{"location":"mcp_server_api_guide/#14-get_outgoing_relations","title":"14. <code>get_outgoing_relations</code>","text":"<ul> <li>Description: Retrieves all outgoing relation instances from a given object.</li> <li>Input Parameters (JSON):</li> <li><code>object_id</code> (string, required, UUID format): ID of the source object.</li> <li><code>type_name</code> (string, required): Object type name of the source object.</li> <li><code>relation_type_name</code> (string, optional): If provided, filters by this relation type.</li> <li> <p>Example Input (JSON):</p> <p><code>json {     \"object_id\": \"doc1-uuid\",     \"type_name\": \"Document\",     \"relation_type_name\": \"AUTHORED_BY\" }</code></p> </li> <li> <p>Output Parameters (JSON):</p> </li> <li> <p>Returns a list of <code>RelationInstance</code> objects.</p> </li> <li> <p>Example Output (JSON):</p> <p><code>json [     {         \"id\": \"rel1-uuid\",         \"weight\": 1.0,         \"upsert_date\": \"2024-06-04T20:15:00Z\",         \"relation_type_name\": \"AUTHORED_BY\",         \"source_object_instance_id\": \"doc1-uuid\",         \"target_object_instance_id\": \"person_xyz-uuid\",         \"properties\": { \"role\": \"Primary Author\" }     } ]</code></p> </li> </ul>"},{"location":"mcp_server_api_guide/#15-get_incoming_relations","title":"15. <code>get_incoming_relations</code>","text":"<ul> <li>Description: Retrieves all incoming relation instances to a given object.</li> <li>Input Parameters (JSON):</li> <li><code>object_id</code> (string, required, UUID format): ID of the target object.</li> <li><code>type_name</code> (string, required): Object type name of the target object.</li> <li><code>relation_type_name</code> (string, optional): If provided, filters by this relation type.</li> <li> <p>Example Input (JSON):</p> <p><code>json {     \"object_id\": \"person_xyz-uuid\",     \"type_name\": \"Person\",     \"relation_type_name\": \"AUTHORED_BY\" }</code></p> </li> <li> <p>Output Parameters (JSON):</p> </li> <li> <p>Returns a list of <code>RelationInstance</code> objects.</p> </li> <li> <p>Example Output (JSON): (Same structure as <code>get_outgoing_relations</code> output)</p> </li> </ul>"},{"location":"mcp_server_api_guide/#querying","title":"Querying","text":""},{"location":"mcp_server_api_guide/#16-search_similar_objects","title":"16. <code>search_similar_objects</code>","text":"<ul> <li>Description: Searches for objects similar to a given object, typically using embeddings. (Note: The Grizabella API for this might involve providing an embedding vector directly or specifying an object whose embedding should be used. The MCP layer currently expects object ID and type name.)</li> <li>Input Parameters (JSON):</li> <li><code>object_id</code> (string, required, UUID format): ID of the object to find similar items for.</li> <li><code>type_name</code> (string, required): Object type name of the object.</li> <li><code>n_results</code> (integer, optional, default: <code>5</code>): Number of similar results to return.</li> <li><code>search_properties</code> (array of strings, optional): List of property names to consider for similarity (if applicable to the underlying embedding strategy).</li> <li> <p>Example Input (JSON):</p> <p><code>json {     \"object_id\": \"doc1-uuid\",     \"type_name\": \"Document\",     \"n_results\": 3 }</code></p> </li> <li> <p>Output Parameters (JSON):</p> </li> <li>Returns a list of tuples, where each tuple contains an <code>ObjectInstance</code> and a float representing the similarity score.</li> <li> <p>The JSON structure will be an array of arrays/objects, e.g., <code>[[ObjectInstance, score], [ObjectInstance, score]]</code>.</p> </li> <li> <p>Example Output (JSON):</p> <p><code>json [     [         {             \"id\": \"doc_similar1_uuid\",             \"weight\": 1.0,             \"upsert_date\": \"2024-06-01T10:00:00Z\",             \"object_type_name\": \"Document\",             \"properties\": { \"title\": \"A Very Similar Document\" }         },         0.95     ],     [         {             \"id\": \"doc_similar2_uuid\",             \"weight\": 1.0,             \"upsert_date\": \"2024-05-20T14:30:00Z\",             \"object_type_name\": \"Document\",             \"properties\": { \"title\": \"Another Related Article\" }         },         0.88     ] ]</code></p> </li> </ul>"},{"location":"mcp_server_api_guide/#17-execute_complex_query","title":"17. <code>execute_complex_query</code>","text":"<ul> <li>Description: Executes a complex query that can span multiple database layers (relational, graph, vector) and object types.</li> <li>Input Parameters (JSON):</li> <li><code>query</code> (object, required): The complex query definition. This structure is based on the <code>ComplexQuery</code> Pydantic model.<ul> <li><code>description</code> (string, optional): Optional description for the query.</li> <li><code>components</code> (array, required): List of <code>QueryComponent</code> objects.</li> <li>Each <code>QueryComponent</code> (<code>QueryComponent</code>) has:<ul> <li><code>object_type_name</code> (string, required): Primary object type for this component.</li> <li><code>relational_filters</code> (array, optional): List of <code>RelationalFilter</code> objects.</li> <li>Each <code>RelationalFilter</code> (<code>RelationalFilter</code>) has:<ul> <li><code>property_name</code> (string, required)</li> <li><code>operator</code> (string, required, e.g., \"==\", \"!=\", \"LIKE\", \"IN\")</li> <li><code>value</code> (any, required)</li> </ul> </li> <li><code>embedding_searches</code> (array, optional): List of <code>EmbeddingSearchClause</code> objects.</li> <li>Each <code>EmbeddingSearchClause</code> (<code>EmbeddingSearchClause</code>) has:<ul> <li><code>embedding_definition_name</code> (string, required)</li> <li><code>similar_to_payload</code> (array of floats, required): The query vector.</li> <li><code>threshold</code> (float, optional)</li> <li><code>limit</code> (integer, optional, default: 10)</li> </ul> </li> <li><code>graph_traversals</code> (array, optional): List of <code>GraphTraversalClause</code> objects.</li> <li>Each <code>GraphTraversalClause</code> (<code>GraphTraversalClause</code>) has:<ul> <li><code>relation_type_name</code> (string, required)</li> <li><code>direction</code> (string, optional, \"outgoing\" or \"incoming\", default: \"outgoing\")</li> <li><code>target_object_type_name</code> (string, required)</li> <li><code>target_object_id</code> (string, optional, UUID format)</li> <li><code>target_object_properties</code> (array, optional): List of <code>RelationalFilter</code> objects for the target.</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>Example Input (JSON):</p> <p><code>json {     \"query\": {         \"description\": \"Find recent documents by 'John Doe' that mention 'AI research'.\",         \"components\": [             {                 \"object_type_name\": \"Person\",                 \"relational_filters\": [                     {                         \"property_name\": \"name\",                         \"operator\": \"==\",                         \"value\": \"John Doe\"                     }                 ]             },             {                 \"object_type_name\": \"Document\",                 \"relational_filters\": [                     {                         \"property_name\": \"published_date\",                         \"operator\": \"&gt;=\",                         \"value\": \"2024-01-01T00:00:00Z\"                     }                 ],                 \"embedding_searches\": [                     {                         \"embedding_definition_name\": \"document_content_embedding\",                         \"similar_to_payload\": [0.1, 0.2, ..., 0.9], // Example vector for \"AI research\"                         \"limit\": 5                     }                 ],                 \"graph_traversals\": [                     {                         \"relation_type_name\": \"AUTHORED_BY\",                         \"direction\": \"incoming\", // Document is target, Person is source                         \"target_object_type_name\": \"Person\"                         // Link to the \"Person\" component implicitly by the query engine logic                     }                 ]             }         ]     } }</code></p> </li> <li> <p>Output Parameters (JSON):</p> </li> <li> <p>Returns a <code>QueryResult</code> object.</p> <ul> <li><code>object_instances</code> (array): List of <code>ObjectInstance</code> objects that match the query.</li> <li><code>errors</code> (array of strings, optional): List of errors encountered, if any.</li> </ul> </li> <li> <p>Example Output (JSON):</p> <p><code>json {     \"object_instances\": [         {             \"id\": \"doc_ai_1_uuid\",             \"weight\": 1.0,             \"upsert_date\": \"2024-03-10T12:00:00Z\",             \"object_type_name\": \"Document\",             \"properties\": {                 \"title\": \"Advancements in AI Research\",                 \"content\": \"...\",                 \"published_date\": \"2024-03-10T12:00:00Z\"             }         }     ],     \"errors\": null }</code></p> </li> </ul>"},{"location":"mcp_server_api_guide/#example-curl-requests","title":"Example <code>curl</code> Requests","text":"<p>Here are a few examples of how to interact with the MCP server using <code>curl</code>. Assume the server is running on <code>http://localhost:8000</code> (the default for FastAPI/Uvicorn, adjust if your FastMCP setup uses a different port). The MCP protocol usually involves a POST request with a JSON body.</p>"},{"location":"mcp_server_api_guide/#1-create-an-object-type","title":"1. Create an Object Type**","text":"<pre><code>curl -X POST http://localhost:8000/mcp \\\n-H \"Content-Type: application/json\" \\\n-d '{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"create_object_type\",\n    \"params\": {\n        \"object_type_def\": {\n            \"name\": \"Person\",\n            \"properties\": [\n                {\"name\": \"full_name\", \"data_type\": \"TEXT\"},\n                {\"name\": \"email\", \"data_type\": \"TEXT\", \"is_unique\": true}\n            ]\n        }\n    },\n    \"id\": 1\n}'\n</code></pre> <p>(Note: The exact JSON-RPC structure (<code>jsonrpc</code>, <code>method</code>, <code>params</code>, <code>id</code>) might vary slightly based on FastMCP's specific implementation. The <code>params</code> would contain the arguments for the tool, e.g., <code>{\"object_type_def\": {...}}</code> for <code>create_object_type</code>.)</p> <p>If FastMCP uses a simpler REST-like mapping where tool names are part of the URL, it might look different, e.g., <code>POST http://localhost:8000/create_object_type</code>. The examples above assume a common MCP/JSON-RPC pattern where the tool name is in the <code>method</code> field. For Grizabella's <code>FastMCP</code> usage, it's more likely that the parameters are directly passed as the JSON body for a POST request to a tool-specific endpoint (e.g. <code>POST /create_object_type</code> with the body being <code>{\"object_type_def\": {...}}</code>).</p> <p>Let's assume a simpler POST to <code>/tool_name</code> with direct parameters:</p>"},{"location":"mcp_server_api_guide/#1-create-an-object-type-simpler-post","title":"1. Create an Object Type (Simpler POST)","text":"<pre><code>curl -X POST http://localhost:8000/create_object_type \\\n-H \"Content-Type: application/json\" \\\n-d '{\n    \"object_type_def\": {\n        \"name\": \"Person\",\n        \"description\": \"A human being.\",\n        \"properties\": [\n            {\"name\": \"full_name\", \"data_type\": \"TEXT\", \"is_indexed\": true},\n            {\"name\": \"email\", \"data_type\": \"TEXT\", \"is_unique\": true, \"is_nullable\": true},\n            {\"name\": \"age\", \"data_type\": \"INTEGER\", \"is_nullable\": true}\n        ]\n    }\n}'\n</code></pre>"},{"location":"mcp_server_api_guide/#2-upsert-an-object-instance","title":"2. Upsert an Object Instance","text":"<pre><code>curl -X POST http://localhost:8000/upsert_object \\\n-H \"Content-Type: application/json\" \\\n-d '{\n    \"obj\": {\n        \"object_type_name\": \"Person\",\n        \"properties\": {\n            \"full_name\": \"Jane Doe\",\n            \"email\": \"jane.doe@example.com\",\n            \"age\": 30\n        }\n    }\n}'\n</code></pre> <p>Response:</p> <pre><code>{\n    \"id\": \"generated-uuid-for-jane\",\n    \"weight\": 1.0,\n    \"upsert_date\": \"YYYY-MM-DDTHH:MM:SS.ffffffZ\",\n    \"object_type_name\": \"Person\",\n    \"properties\": {\n        \"full_name\": \"Jane Doe\",\n        \"email\": \"jane.doe@example.com\",\n        \"age\": 30\n    }\n}\n</code></pre>"},{"location":"mcp_server_api_guide/#3-get-an-object-by-id","title":"3. Get an Object by ID","text":"<pre><code>curl -X POST http://localhost:8000/get_object_by_id \\\n-H \"Content-Type: application/json\" \\\n-d '{\n    \"object_id\": \"generated-uuid-for-jane\",\n    \"type_name\": \"Person\"\n}'\n</code></pre>"},{"location":"mcp_server_api_guide/#4-execute-a-complex-query-payload-can-be-large","title":"4. Execute a Complex Query (Payload can be large)","text":"<pre><code>curl -X POST http://localhost:8000/execute_complex_query \\\n-H \"Content-Type: application/json\" \\\n-d '{\n    \"query\": {\n        \"description\": \"Find Person named Jane Doe\",\n        \"components\": [\n            {\n                \"object_type_name\": \"Person\",\n                \"relational_filters\": [\n                    {\n                        \"property_name\": \"full_name\",\n                        \"operator\": \"==\",\n                        \"value\": \"Jane Doe\"\n                    }\n                ]\n            }\n        ]\n    }\n}'\n</code></pre> <p>Please consult the FastMCP documentation or observe server logs for the exact request format if these examples don't work directly. The key is that the JSON payload in the request body should match the input parameters defined for each tool.</p>"},{"location":"pyside6_ui_guide/","title":"Grizabella PySide6 UI Guide","text":"<p>This guide provides a comprehensive walkthrough of the Grizabella PySide6 User Interface. It will help you understand how to navigate the application, manage your graph database schema, explore data, and execute queries.</p>"},{"location":"pyside6_ui_guide/#launching-the-ui","title":"Launching the UI","text":"<p>To launch the Grizabella PySide6 UI, ensure you have Grizabella installed and your environment configured. Open your terminal and run the following command:</p> <pre><code>poetry run grizabella-ui\n</code></pre> <p>This will start the application and open the main window.</p>"},{"location":"pyside6_ui_guide/#connection-view","title":"Connection View","text":"<p>Upon launching, the first view you'll encounter is the Connection View. This view allows you to establish a connection to your Grizabella database.</p> <p>[Screenshot of Connection View]</p> <ul> <li>Default Database: To connect to the default Grizabella database, simply click the \"Connect\" button. The application will attempt to connect to the database at the default location (<code>~/.grizabella/default_db</code>).</li> <li>Named Database: If you have a named database (e.g., <code>my_project_db</code>), you can type its name into the \"Database Name or Path\" field and click \"Connect\". Grizabella will look for this database within its standard database directory.</li> <li>Custom Path: To connect to a database at a specific file system path, you can either type the full path into the \"Database Name or Path\" field or use the \"Browse\" button.</li> <li>Browse Functionality: Clicking the \"Browse\" button opens a file dialog, allowing you to navigate to and select your Grizabella database directory.</li> <li>Status Bar Feedback: The status bar at the bottom of the window will provide feedback on the connection process, indicating whether the connection was successful or if any errors occurred.</li> </ul> <p>Once a successful connection is established, the UI will transition to the main application window.</p>"},{"location":"pyside6_ui_guide/#main-window-layout","title":"Main Window Layout","text":"<p>After successfully connecting to a database, the main window displays a tabbed interface, providing access to different functionalities of Grizabella.</p> <p>[Screenshot of Main Window with Tabs]</p> <p>The main components are organized into the following tabs:</p> <ul> <li>Schema Editor: Manage your database schema, including Object Types, Embedding Definitions, and Relation Types.</li> <li>Object Explorer: View, create, edit, and delete object instances.</li> <li>Relation Explorer: View, create, edit, and delete relation instances.</li> <li>Query View: Execute various types of queries against your database.</li> </ul>"},{"location":"pyside6_ui_guide/#schema-editor","title":"Schema Editor","text":"<p>The Schema Editor is a powerful tool for defining and modifying the structure of your graph database. It consists of three sub-tabs: Object Types, Embedding Definitions, and Relation Types.</p>"},{"location":"pyside6_ui_guide/#1-object-types-view","title":"1. Object Types View","text":"<p>This view allows you to manage the different types of objects (nodes) in your graph.</p> <p>[Screenshot of Object Types View]</p> <ul> <li>Viewing Object Types: A list on the left displays all currently defined Object Types. Clicking on an Object Type in this list will show its details on the right.</li> <li>Viewing Details: The details panel shows:</li> <li>Name: The unique name of the Object Type.</li> <li>Description: A user-provided description of the Object Type.</li> <li>Properties Table: A table listing all properties defined for this Object Type, including their:<ul> <li>Name</li> <li>Data Type (e.g., <code>string</code>, <code>integer</code>, <code>float</code>, <code>boolean</code>, <code>list&lt;string&gt;</code>, <code>vector&lt;float&gt;</code>)</li> <li>Primary Key (PK): Indicates if the property is part of the primary key.</li> <li>Nullable: Indicates if the property can have null values.</li> <li>Default Value: The default value for the property, if any.</li> </ul> </li> <li>\"New Object Type\" Button:</li> <li>Clicking this button opens the <code>ObjectTypeDialog</code>.</li> <li>[Screenshot of ObjectTypeDialog]</li> <li><code>ObjectTypeDialog</code> Fields:<ul> <li>Name: Enter a unique name for the new Object Type.</li> <li>Description: Provide a meaningful description.</li> <li>Properties Table:</li> <li>Use the \"Add Property\" button to add a new row to the table.</li> <li>For each property, you can specify:<ul> <li>Name: The property's name.</li> <li>Data Type: Select from a dropdown of supported data types.</li> <li>PK: Check this box if the property is a primary key.</li> <li>Nullable: Check this box if the property can be null.</li> <li>Default: Optionally, provide a default value.</li> </ul> </li> <li>Use the \"Remove Selected Property\" button to delete a property from the list.</li> </ul> </li> <li>Click \"OK\" to create the new Object Type or \"Cancel\" to discard.</li> <li>\"Edit Selected\" Button: Select an Object Type from the list and click this button to open the <code>ObjectTypeDialog</code> pre-filled with its current details, allowing you to modify it.</li> <li>\"Delete Selected\" Button: Select an Object Type from the list and click this button to delete it. A confirmation dialog will appear.</li> </ul>"},{"location":"pyside6_ui_guide/#2-embedding-definitions-view","title":"2. Embedding Definitions View","text":"<p>This view manages how embeddings are generated and stored for your objects. Embeddings are crucial for similarity searches and other machine learning tasks.</p> <p>[Screenshot of Embedding Definitions View]</p> <ul> <li>Structure: Similar to the Object Types view, it features a list of existing Embedding Definitions on the left and a details panel on the right.</li> <li>Details: When an Embedding Definition is selected, its details are displayed, including its name, the Object Type it applies to, the source property used for embedding, the embedding model, dimensions, and description.</li> <li>\"New Embedding Definition\" Button:</li> <li>Opens the <code>EmbeddingDefinitionDialog</code>.</li> <li>[Screenshot of EmbeddingDefinitionDialog]</li> <li><code>EmbeddingDefinitionDialog</code> Fields:<ul> <li>Name: A unique name for this embedding definition.</li> <li>Object Type: A dropdown list to select the Object Type for which this embedding will be generated.</li> <li>Source Property: A dropdown list of properties from the selected Object Type. This list is dynamically populated based on the chosen Object Type. This property's value will be used as input to the embedding model.</li> <li>Model: Specify the embedding model to be used (e.g., <code>all-MiniLM-L6-v2</code>).</li> <li>Dimensions: The dimensionality of the embedding vector produced by the model.</li> <li>Description: An optional description for this embedding definition.</li> </ul> </li> <li>Click \"OK\" to create or \"Cancel\" to discard.</li> <li>\"Edit Selected\" Button: (Placeholder for future functionality) Currently, editing might involve deleting and recreating.</li> <li>\"Delete Selected\" Button: Deletes the selected Embedding Definition after confirmation.</li> </ul>"},{"location":"pyside6_ui_guide/#3-relation-types-view","title":"3. Relation Types View","text":"<p>This view allows you to define the types of relationships (edges) that can exist between your objects.</p> <p>[Screenshot of Relation Types View]</p> <ul> <li>Structure: Again, a list of Relation Types is on the left, with details appearing on the right upon selection.</li> <li>Details: The details panel shows the Relation Type's name, description, the source Object Type, the target Object Type, and a table of any properties defined for the relation itself.</li> <li>\"New Relation Type\" Button:</li> <li>Opens the <code>RelationTypeDialog</code>.</li> <li>[Screenshot of RelationTypeDialog]</li> <li><code>RelationTypeDialog</code> Fields:<ul> <li>Name: A unique name for the new Relation Type.</li> <li>Description: A description of what this relation represents.</li> <li>Source Object Type: A dropdown to select the Object Type from which relations of this type can originate.</li> <li>Target Object Type: A dropdown to select the Object Type to which relations of this type can point.</li> <li>Properties Table: Similar to the Object Type properties table, you can define properties specific to the relation itself (e.g., <code>weight</code>, <code>timestamp</code>, <code>role</code>). Use \"Add Property\" and \"Remove Selected Property\" to manage these.</li> </ul> </li> <li>Click \"OK\" to create or \"Cancel\" to discard.</li> <li>\"Edit Selected\" Button: (Placeholder for future functionality)</li> <li>\"Delete Selected\" Button: Deletes the selected Relation Type after confirmation.</li> </ul>"},{"location":"pyside6_ui_guide/#object-explorer-view","title":"Object Explorer View","text":"<p>The Object Explorer allows you to browse, create, modify, and delete instances of your defined Object Types.</p> <p>[Screenshot of Object Explorer View]</p> <ul> <li>Select Object Type: Use the dropdown menu at the top to choose the Object Type whose instances you want to view.</li> <li>Instances Table: Once an Object Type is selected, the table below will populate with its instances.</li> <li>The columns in this table are dynamically generated based on the properties of the selected Object Type.</li> <li>\"New Object\" Button:</li> <li>Opens the <code>ObjectInstanceDialog</code>.</li> <li>[Screenshot of ObjectInstanceDialog for a sample Object Type]</li> <li><code>ObjectInstanceDialog</code>: This dialog presents a form that is dynamically generated based on the properties of the Object Type selected in the explorer.<ul> <li>For each property, an appropriate input field is provided (e.g., line edit for strings, spin box for integers).</li> <li>A special <code>weight</code> field might be present for certain configurations, typically used in graph algorithms.</li> </ul> </li> <li>Fill in the property values and click \"OK\" to create the new object instance.</li> <li>\"View/Edit Selected\" Button: Select an object instance from the table and click this button. The <code>ObjectInstanceDialog</code> will open, pre-filled with the selected object's data, allowing you to view or modify its properties.</li> <li>\"Delete Selected\" Button: Select an object instance and click this button to delete it after confirmation.</li> <li>\"Refresh List\" Button: Click this to reload the list of object instances from the database, reflecting any recent changes.</li> </ul>"},{"location":"pyside6_ui_guide/#relation-explorer-view","title":"Relation Explorer View","text":"<p>The Relation Explorer is used to manage instances of the relationships defined in your schema.</p> <p>[Screenshot of Relation Explorer View]</p> <ul> <li>Select Relation Type: Choose a Relation Type from the dropdown menu to view its instances.</li> <li>Optional Filters:</li> <li>Source Object ID: You can filter relations by the ID of their source object.</li> <li>Target Object ID: You can filter relations by the ID of their target object.</li> <li>Enter the respective IDs and apply the filter to narrow down the list.</li> <li>Instances Table: The table displays instances of the selected Relation Type, matching any applied filters. Columns will include source ID, target ID, and any properties defined for the Relation Type.</li> <li>\"New Relation\" Button:</li> <li>Opens the <code>RelationInstanceDialog</code>.</li> <li>[Screenshot of RelationInstanceDialog for a sample Relation Type, showing ComboBoxes for Source and Target Object selection]</li> <li><code>RelationInstanceDialog</code> Fields:<ul> <li>Relation Type: Pre-selected based on the explorer's context, or selectable if opened generically.</li> <li>Source Object: Select the source object instance for this relation using a filterable dropdown list (ComboBox). This replaces manual ID input and helps ensure the object exists.</li> <li>Target Object: Select the target object instance for this relation using a filterable dropdown list (ComboBox). This also replaces manual ID input.</li> <li>Dynamic Properties: Input fields for any properties defined for this Relation Type (e.g., <code>weight</code>).</li> <li>A <code>weight</code> field might be present for specifying the strength or cost of the relation.</li> </ul> </li> <li>Click \"OK\" to create the new relation instance.</li> <li>\"View/Edit Selected\" Button: Select a relation instance from the table to open the <code>RelationInstanceDialog</code> with its data pre-filled for viewing or editing.</li> <li>\"Delete Selected\" Button: Deletes the selected relation instance after confirmation.</li> </ul>"},{"location":"pyside6_ui_guide/#query-view","title":"Query View","text":"<p>The Query View is your interface for interacting with Grizabella's query engine, allowing you to retrieve specific data from your graph.</p> <p>[Screenshot of Query View]</p> <ul> <li>Query Type Selector: A dropdown menu allows you to choose the type of query you want to perform:</li> <li>Simple Object Query</li> <li>Embedding Similarity Search</li> <li>Complex Query</li> <li>Executing Queries: After configuring your query parameters, click the \"Execute Query\" button.</li> <li>Results Display: The results of your query will be displayed in the table at the bottom of the view.</li> </ul>"},{"location":"pyside6_ui_guide/#1-simple-object-query","title":"1. Simple Object Query","text":"<p>This allows for basic retrieval of objects based on property conditions.</p> <p>[Screenshot of Simple Object Query section]</p> <ul> <li>Object Type: Select the Object Type you want to query from the dropdown.</li> <li>Conditions: Enter conditions for filtering the objects. The current simple format might be a basic key-value pair or a simple expression (e.g., <code>name = \"Alice\"</code> or <code>age &gt; 30</code>). Refer to specific examples or further documentation for the exact supported syntax.</li> </ul>"},{"location":"pyside6_ui_guide/#2-embedding-similarity-search","title":"2. Embedding Similarity Search","text":"<p>This query type finds objects whose embeddings are most similar to a given query text or vector.</p> <p>[Screenshot of Embedding Similarity Search section]</p> <ul> <li>Embedding Definition: Select the Embedding Definition (which implies an Object Type and an embedding model) to use for the search.</li> <li>Query Text/Vector:</li> <li>Enter query text (which will be embedded using the selected definition's model).</li> <li>Alternatively, you might be able to paste a pre-computed query vector.</li> <li>Limit: Specify the maximum number of similar objects to return.</li> <li>Filter: Optionally, provide additional property-based filters to apply to the candidate objects before or after the similarity search.</li> </ul>"},{"location":"pyside6_ui_guide/#3-complex-query","title":"3. Complex Query","text":"<p>This option is for more advanced queries, typically expressed in a structured format like JSON.</p> <p>[Screenshot of Complex Query section]</p> <ul> <li>JSON Input: A text area is provided where you can enter your complex query in JSON format. This allows for intricate graph traversals, multi-hop queries, and sophisticated filtering logic. Refer to the Grizabella Complex Query Language documentation for details on constructing these queries.</li> <li>Example: <code>{\"object_type\": \"Person\", \"filters\": [{\"property\": \"city\", \"operator\": \"==\", \"value\": \"New York\"}], \"relations\": [{\"relation_type\": \"WORKS_AT\", \"target_object_type\": \"Company\", \"filters\": [{\"property\": \"industry\", \"operator\": \"==\", \"value\": \"Technology\"}]}]}</code> (This is a conceptual example, actual syntax may vary).</li> </ul>"},{"location":"pyside6_ui_guide/#general-ui-concepts","title":"General UI Concepts","text":"<p>Several concepts apply across the Grizabella PySide6 UI:</p> <ul> <li>Threading for API Calls: Most operations that interact with the backend database (e.g., fetching data, creating items, executing queries) are performed in separate threads. This ensures that the UI remains responsive and does not freeze during potentially long-running operations.</li> <li>Error Messages: If an error occurs (e.g., invalid input, database error), a <code>QMessageBox</code> dialog will typically appear, displaying a descriptive error message to inform the user.</li> <li>Status Bar Updates: The status bar at the bottom of the main window provides ongoing feedback about the application's state, such as \"Connecting to database...\", \"Query executed successfully.\", \"Error: Object Type not found.\", etc. This is a key place to look for quick updates on operations.</li> <li>Appearance: The Grizabella UI uses the <code>qt_material</code> library to apply a modern Material Design theme (specifically, <code>light_blue.xml</code>), enhancing the visual appeal and user experience.</li> </ul> <p>This guide should provide a solid foundation for using the Grizabella PySide6 UI. As new features are added, this documentation will be updated.</p>"},{"location":"python_api_detailed/","title":"Python API Usage - Detailed Guide","text":"<p>This guide provides a detailed walkthrough of the Grizabella Python API, covering connection management, schema definition, data manipulation, and querying.</p>"},{"location":"python_api_detailed/#connecting-to-grizabella","title":"Connecting to Grizabella","text":"<p>The primary entry point to interacting with Grizabella is the <code>Grizabella</code> class from the <code>grizabella.api.client</code> module.</p>"},{"location":"python_api_detailed/#grizabelladb_name_or_path-unionstr-path-default-create_if_not_exists-bool-true","title":"<code>Grizabella(db_name_or_path: Union[str, Path] = \"default\", create_if_not_exists: bool = True)</code>","text":"<p>Parameters:</p> <ul> <li><code>db_name_or_path</code> (Union[str, Path], optional):</li> <li>Specifies the database instance to connect to.</li> <li>If a string like <code>\"my_db\"</code> is provided, Grizabella manages it in a default location (e.g., <code>~/.grizabella/databases/my_db</code>).</li> <li>If a <code>pathlib.Path</code> object or a string representing a full path is provided, Grizabella uses that specific directory.</li> <li>Defaults to <code>\"default\"</code>, which uses <code>~/.grizabella/databases/default</code>.</li> <li><code>create_if_not_exists</code> (bool, optional):</li> <li>If <code>True</code> (the default), the database directory and necessary files will be created if they don't already exist.</li> <li>If <code>False</code> and the database does not exist, an error will likely occur upon trying to connect or perform operations.</li> </ul> <p>Default Behavior:</p> <p>Initializing <code>Grizabella()</code> without arguments connects to (or creates) a database named \"default\" in the standard Grizabella data directory.</p> <p>Usage with <code>with</code> Statement:</p> <p>The recommended way to use the <code>Grizabella</code> client is with a <code>with</code> statement. This ensures that the database connection is automatically opened when entering the block and closed when exiting, even if errors occur.</p> <pre><code>from pathlib import Path\nfrom grizabella import Grizabella\nfrom grizabella.core.models import ObjectTypeDefinition, PropertyDefinition, PropertyDataType\n\n# Example using the 'with' statement for automatic connection management\ndb_path = Path(\"./my_grizabella_db\")\n\ntry:\n    with Grizabella(db_name_or_path=db_path, create_if_not_exists=True) as gz:\n        # The connection is now active within this block\n        print(f\"Successfully connected to Grizabella database at: {gz._db_manager.db_path}\")\n\n        # You can now perform operations, e.g., list object types\n        object_types = gz.list_object_types()\n        if not object_types:\n            print(\"No object types found yet.\")\n        else:\n            print(\"Existing object types:\")\n            for ot_def in object_types:\n                print(f\"- {ot_def.name}\")\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n\n# Outside the 'with' block, the connection is automatically closed.\n</code></pre>"},{"location":"python_api_detailed/#schema-management","title":"Schema Management","text":"<p>Schema management involves defining the structure of your data using Object Types, Embedding Definitions, and Relation Types.</p>"},{"location":"python_api_detailed/#object-type-management","title":"Object Type Management","text":""},{"location":"python_api_detailed/#create_object_typeobject_type_def-objecttypedefinition-none","title":"<code>create_object_type(object_type_def: ObjectTypeDefinition) -&gt; None</code>","text":"<ul> <li>Signature: <code>def create_object_type(self, object_type_def: ObjectTypeDefinition) -&gt; None:</code></li> <li>Purpose: Creates a new object type (e.g., a table schema or node label) in the database.</li> <li>Example:</li> </ul> <pre><code>from grizabella import Grizabella\nfrom grizabella.core.models import ObjectTypeDefinition, PropertyDefinition, PropertyDataType\n\n# Define an Object Type for \"User\"\nuser_type_def = ObjectTypeDefinition(\n    name=\"User\",\n    description=\"Represents a user in the system.\",\n    properties=[\n        PropertyDefinition(name=\"user_id\", data_type=PropertyDataType.TEXT, is_primary_key=True, is_unique=True, is_indexed=True),\n        PropertyDefinition(name=\"username\", data_type=PropertyDataType.TEXT, is_unique=True, is_indexed=True),\n        PropertyDefinition(name=\"email\", data_type=PropertyDataType.TEXT, is_unique=True),\n        PropertyDefinition(name=\"full_name\", data_type=PropertyDataType.TEXT, is_nullable=True),\n        PropertyDefinition(name=\"join_date\", data_type=PropertyDataType.DATETIME),\n        PropertyDefinition(name=\"is_active\", data_type=PropertyDataType.BOOLEAN, default=True) # Default not directly in model, but conceptual\n    ]\n)\n\nwith Grizabella(db_name_or_path=\"user_guide_db\") as gz:\n    try:\n        gz.create_object_type(user_type_def)\n        print(f\"Object type '{user_type_def.name}' created successfully.\")\n    except Exception as e: # Replace with specific Grizabella exceptions if available\n        print(f\"Error creating object type '{user_type_def.name}': {e}\")\n</code></pre>"},{"location":"python_api_detailed/#get_object_type_definitiontype_name-str-optionalobjecttypedefinition","title":"<code>get_object_type_definition(type_name: str) -&gt; Optional[ObjectTypeDefinition]</code>","text":"<ul> <li>Signature: <code>def get_object_type_definition(self, type_name: str) -&gt; Optional[ObjectTypeDefinition]:</code></li> <li>Purpose: Retrieves the definition of a specific object type.</li> <li>Example:</li> </ul> <pre><code># Assuming 'gz' is an active Grizabella client from the previous example\nwith Grizabella(db_name_or_path=\"user_guide_db\") as gz:\n    user_type_name = \"User\"\n    retrieved_def = gz.get_object_type_definition(user_type_name)\n\n    if retrieved_def:\n        print(f\"Retrieved definition for '{retrieved_def.name}':\")\n        for prop in retrieved_def.properties:\n            print(f\"  - {prop.name} ({prop.data_type.value})\")\n    else:\n        print(f\"Object type '{user_type_name}' not found.\")\n</code></pre>"},{"location":"python_api_detailed/#list_object_types-listobjecttypedefinition","title":"<code>list_object_types() -&gt; List[ObjectTypeDefinition]</code>","text":"<ul> <li>Signature: <code>def list_object_types(self) -&gt; List[ObjectTypeDefinition]:</code></li> <li>Purpose: Lists all object type definitions currently in the database.</li> <li>Example:</li> </ul> <pre><code># Assuming 'gz' is an active Grizabella client\nwith Grizabella(db_name_or_path=\"user_guide_db\") as gz:\n    all_object_types = gz.list_object_types()\n    if all_object_types:\n        print(\"All defined object types:\")\n        for ot_def in all_object_types:\n            print(f\"- {ot_def.name} (Description: {ot_def.description or 'N/A'})\")\n    else:\n        print(\"No object types are defined in the database yet.\")\n</code></pre>"},{"location":"python_api_detailed/#delete_object_typetype_name-str-none","title":"<code>delete_object_type(type_name: str) -&gt; None</code>","text":"<ul> <li>Signature: <code>def delete_object_type(self, type_name: str) -&gt; None:</code></li> <li>Purpose: Deletes an object type definition from the database. Warning: This may also delete all associated object instances and relations.</li> <li>Example:</li> </ul> <pre><code># Assuming 'gz' is an active Grizabella client\n# with Grizabella(db_name_or_path=\"user_guide_db\") as gz:\n#     type_to_delete = \"TemporaryType\"\n#     # First, create it if it doesn't exist for the example to run\n#     if not gz.get_object_type_definition(type_to_delete):\n#         temp_type = ObjectTypeDefinition(name=type_to_delete, properties=[PropertyDefinition(name=\"field\", data_type=PropertyDataType.TEXT)])\n#         gz.create_object_type(temp_type)\n#         print(f\"Created '{type_to_delete}' for deletion example.\")\n#\n#     try:\n#         gz.delete_object_type(type_to_delete)\n#         print(f\"Object type '{type_to_delete}' deleted successfully.\")\n#     except Exception as e: # Replace with specific Grizabella exceptions\n#         print(f\"Error deleting object type '{type_to_delete}': {e}\")\n</code></pre>"},{"location":"python_api_detailed/#embedding-definition-management","title":"Embedding Definition Management","text":""},{"location":"python_api_detailed/#create_embedding_definitionembedding_def-embeddingdefinition-embeddingdefinition","title":"<code>create_embedding_definition(embedding_def: EmbeddingDefinition) -&gt; EmbeddingDefinition</code>","text":"<ul> <li>Signature: <code>def create_embedding_definition(self, embedding_def: EmbeddingDefinition) -&gt; EmbeddingDefinition:</code></li> <li>Purpose: Creates a new embedding definition, specifying how embeddings are generated for a particular object type and property.</li> <li>Example:</li> </ul> <pre><code>from grizabella import Grizabella\nfrom grizabella.core.models import EmbeddingDefinition, ObjectTypeDefinition, PropertyDefinition, PropertyDataType\n\n# First, ensure the Object Type \"User\" exists (from previous example)\nwith Grizabella(db_name_or_path=\"user_guide_db\") as gz:\n    if not gz.get_object_type_definition(\"User\"):\n        user_type_def = ObjectTypeDefinition(\n            name=\"User\",\n            properties=[\n                PropertyDefinition(name=\"user_id\", data_type=PropertyDataType.TEXT, is_primary_key=True),\n                PropertyDefinition(name=\"username\", data_type=PropertyDataType.TEXT),\n                PropertyDefinition(name=\"profile_bio\", data_type=PropertyDataType.TEXT) # Property to embed\n            ]\n        )\n        gz.create_object_type(user_type_def)\n        print(\"Created 'User' object type for embedding example.\")\n\n\n    # Define an Embedding Definition for the \"profile_bio\" property of \"User\"\n    user_bio_embedding_def = EmbeddingDefinition(\n        name=\"user_profile_bio_sbert\",\n        object_type_name=\"User\",\n        source_property_name=\"profile_bio\",\n        embedding_model=\"sentence-transformers/all-MiniLM-L6-v2\", # Example model\n        dimensions=384, # Example dimension for the chosen model\n        description=\"Embeds user profile bios using Sentence-BERT for similarity search.\"\n    )\n\n    try:\n        created_emb_def = gz.create_embedding_definition(user_bio_embedding_def)\n        print(f\"Embedding definition '{created_emb_def.name}' created successfully.\")\n    except Exception as e:\n        print(f\"Error creating embedding definition '{user_bio_embedding_def.name}': {e}\")\n</code></pre>"},{"location":"python_api_detailed/#get_embedding_definitionname-str-optionalembeddingdefinition","title":"<code>get_embedding_definition(name: str) -&gt; Optional[EmbeddingDefinition]</code>","text":"<ul> <li>Signature: <code>def get_embedding_definition(self, name: str) -&gt; Optional[EmbeddingDefinition]:</code></li> <li>Purpose: Retrieves a specific embedding definition by its name.</li> <li>Example:</li> </ul> <pre><code># Assuming 'gz' is an active Grizabella client\nwith Grizabella(db_name_or_path=\"user_guide_db\") as gz:\n    emb_def_name = \"user_profile_bio_sbert\"\n    retrieved_emb_def = gz.get_embedding_definition(emb_def_name)\n\n    if retrieved_emb_def:\n        print(f\"Retrieved embedding definition '{retrieved_emb_def.name}':\")\n        print(f\"  - Object Type: {retrieved_emb_def.object_type_name}\")\n        print(f\"  - Source Property: {retrieved_emb_def.source_property_name}\")\n        print(f\"  - Model: {retrieved_emb_def.embedding_model}\")\n    else:\n        print(f\"Embedding definition '{emb_def_name}' not found.\")\n</code></pre>"},{"location":"python_api_detailed/#list_embedding_definitions-listembeddingdefinition","title":"<code>list_embedding_definitions() -&gt; List[EmbeddingDefinition]</code>","text":"<ul> <li>Signature: <code>def list_embedding_definitions(self) -&gt; List[EmbeddingDefinition]:</code></li> <li>Purpose: Lists all embedding definitions in the database.</li> <li>Example:</li> </ul> <pre><code># Assuming 'gz' is an active Grizabella client\nwith Grizabella(db_name_or_path=\"user_guide_db\") as gz:\n    all_emb_defs = gz.list_embedding_definitions()\n    if all_emb_defs:\n        print(\"All defined embedding definitions:\")\n        for emb_def in all_emb_defs:\n            print(f\"- {emb_def.name} (Model: {emb_def.embedding_model})\")\n    else:\n        print(\"No embedding definitions are defined yet.\")\n</code></pre>"},{"location":"python_api_detailed/#delete_embedding_definitionname-str-bool","title":"<code>delete_embedding_definition(name: str) -&gt; bool</code>","text":"<ul> <li>Signature: <code>def delete_embedding_definition(self, name: str) -&gt; bool:</code></li> <li>Purpose: Deletes an embedding definition. May also delete associated embedding vectors.</li> <li>Example:</li> </ul> <pre><code># Assuming 'gz' is an active Grizabella client\n# with Grizabella(db_name_or_path=\"user_guide_db\") as gz:\n#     emb_def_to_delete = \"temp_embedding_def\"\n#     # Create it first for the example\n#     if not gz.get_object_type_definition(\"TempObj\"):\n#         gz.create_object_type(ObjectTypeDefinition(name=\"TempObj\", properties=[PropertyDefinition(name=\"text\", data_type=PropertyDataType.TEXT)]))\n#     if not gz.get_embedding_definition(emb_def_to_delete):\n#         temp_emb_def = EmbeddingDefinition(name=emb_def_to_delete, object_type_name=\"TempObj\", source_property_name=\"text\", embedding_model=\"test-model\")\n#         gz.create_embedding_definition(temp_emb_def)\n#         print(f\"Created '{emb_def_to_delete}' for deletion example.\")\n#\n#     try:\n#         deleted = gz.delete_embedding_definition(emb_def_to_delete)\n#         if deleted:\n#             print(f\"Embedding definition '{emb_def_to_delete}' deleted successfully.\")\n#         else:\n#             print(f\"Embedding definition '{emb_def_to_delete}' not found or not deleted.\")\n#     except Exception as e:\n#         print(f\"Error deleting embedding definition '{emb_def_to_delete}': {e}\")\n</code></pre>"},{"location":"python_api_detailed/#relation-type-management","title":"Relation Type Management","text":""},{"location":"python_api_detailed/#create_relation_typerelation_type_def-relationtypedefinition-none","title":"<code>create_relation_type(relation_type_def: RelationTypeDefinition) -&gt; None</code>","text":"<ul> <li>Signature: <code>def create_relation_type(self, relation_type_def: RelationTypeDefinition) -&gt; None:</code></li> <li>Purpose: Creates a new relation type, defining the schema for relationships between objects.</li> <li>Example:</li> </ul> <pre><code>from grizabella import Grizabella\nfrom grizabella.core.models import RelationTypeDefinition, PropertyDefinition, PropertyDataType, ObjectTypeDefinition\n\n# Ensure source and target Object Types exist (e.g., \"User\" and \"Post\")\nwith Grizabella(db_name_or_path=\"user_guide_db\") as gz:\n    if not gz.get_object_type_definition(\"User\"):\n        user_type_def = ObjectTypeDefinition(name=\"User\", properties=[PropertyDefinition(name=\"user_id\", data_type=PropertyDataType.TEXT, is_primary_key=True)])\n        gz.create_object_type(user_type_def)\n    if not gz.get_object_type_definition(\"Post\"):\n        post_type_def = ObjectTypeDefinition(name=\"Post\", properties=[PropertyDefinition(name=\"post_id\", data_type=PropertyDataType.TEXT, is_primary_key=True)])\n        gz.create_object_type(post_type_def)\n    print(\"Ensured 'User' and 'Post' object types exist for relation example.\")\n\n    # Define a Relation Type \"AUTHORED\"\n    authored_relation_def = RelationTypeDefinition(\n        name=\"AUTHORED\",\n        description=\"Indicates that a User authored a Post.\",\n        source_object_type_names=[\"User\"],\n        target_object_type_names=[\"Post\"],\n        properties=[\n            PropertyDefinition(name=\"authored_date\", data_type=PropertyDataType.DATETIME),\n            PropertyDefinition(name=\"is_primary_author\", data_type=PropertyDataType.BOOLEAN, default=True)\n        ]\n    )\n\n    try:\n        gz.create_relation_type(authored_relation_def)\n        print(f\"Relation type '{authored_relation_def.name}' created successfully.\")\n    except Exception as e:\n        print(f\"Error creating relation type '{authored_relation_def.name}': {e}\")\n</code></pre>"},{"location":"python_api_detailed/#get_relation_typetype_name-str-optionalrelationtypedefinition","title":"<code>get_relation_type(type_name: str) -&gt; Optional[RelationTypeDefinition]</code>","text":"<ul> <li>Signature: <code>def get_relation_type(self, type_name: str) -&gt; Optional[RelationTypeDefinition]:</code></li> <li>Purpose: Retrieves the definition of a specific relation type.</li> <li>Example:</li> </ul> <pre><code># Assuming 'gz' is an active Grizabella client\nwith Grizabella(db_name_or_path=\"user_guide_db\") as gz:\n    relation_type_name = \"AUTHORED\"\n    retrieved_rel_def = gz.get_relation_type(relation_type_name)\n\n    if retrieved_rel_def:\n        print(f\"Retrieved definition for relation type '{retrieved_rel_def.name}':\")\n        print(f\"  - Source Types: {retrieved_rel_def.source_object_type_names}\")\n        print(f\"  - Target Types: {retrieved_rel_def.target_object_type_names}\")\n        if retrieved_rel_def.properties:\n            print(\"  - Properties:\")\n            for prop in retrieved_rel_def.properties:\n                print(f\"    - {prop.name} ({prop.data_type.value})\")\n    else:\n        print(f\"Relation type '{relation_type_name}' not found.\")\n</code></pre>"},{"location":"python_api_detailed/#delete_relation_typetype_name-str-none","title":"<code>delete_relation_type(type_name: str) -&gt; None</code>","text":"<ul> <li>Signature: <code>def delete_relation_type(self, type_name: str) -&gt; None:</code></li> <li>Purpose: Deletes a relation type definition. Warning: May also delete associated relation instances.</li> <li>Example:</li> </ul> <pre><code># Assuming 'gz' is an active Grizabella client\n# with Grizabella(db_name_or_path=\"user_guide_db\") as gz:\n#     rel_type_to_delete = \"TEMP_RELATION\"\n#     # Create it first for the example\n#     if not gz.get_object_type_definition(\"ObjA\"): gz.create_object_type(ObjectTypeDefinition(name=\"ObjA\", properties=[]))\n#     if not gz.get_object_type_definition(\"ObjB\"): gz.create_object_type(ObjectTypeDefinition(name=\"ObjB\", properties=[]))\n#\n#     if not gz.get_relation_type(rel_type_to_delete):\n#         temp_rel_def = RelationTypeDefinition(name=rel_type_to_delete, source_object_type_names=[\"ObjA\"], target_object_type_names=[\"ObjB\"])\n#         gz.create_relation_type(temp_rel_def)\n#         print(f\"Created '{rel_type_to_delete}' for deletion example.\")\n#\n#     try:\n#         gz.delete_relation_type(rel_type_to_delete)\n#         print(f\"Relation type '{rel_type_to_delete}' deleted successfully.\")\n#     except Exception as e:\n#         print(f\"Error deleting relation type '{rel_type_to_delete}': {e}\")\n</code></pre>"},{"location":"python_api_detailed/#data-management","title":"Data Management","text":"<p>Data management involves creating, retrieving, updating, and deleting instances of your defined schemas (Objects and Relations).</p>"},{"location":"python_api_detailed/#object-instance-management","title":"Object Instance Management","text":""},{"location":"python_api_detailed/#upsert_objectobj-objectinstance-objectinstance","title":"<code>upsert_object(obj: ObjectInstance) -&gt; ObjectInstance</code>","text":"<ul> <li>Signature: <code>def upsert_object(self, obj: ObjectInstance) -&gt; ObjectInstance:</code></li> <li>Purpose: Creates a new object instance or updates an existing one if an object with the same <code>id</code> already exists. The <code>upsert_date</code> metadata field is automatically updated. The <code>weight</code> field can be set or defaults to 1.0.</li> <li>Example:</li> </ul> <pre><code>import uuid\nfrom datetime import datetime, timezone\nfrom grizabella import Grizabella\nfrom grizabella.core.models import ObjectInstance, ObjectTypeDefinition, PropertyDefinition, PropertyDataType\n\n# Ensure \"User\" ObjectType exists\nwith Grizabella(db_name_or_path=\"user_guide_db\") as gz:\n    if not gz.get_object_type_definition(\"User\"):\n        user_type_def = ObjectTypeDefinition(\n            name=\"User\",\n            properties=[\n                PropertyDefinition(name=\"user_id\", data_type=PropertyDataType.TEXT, is_primary_key=True),\n                PropertyDefinition(name=\"username\", data_type=PropertyDataType.TEXT),\n                PropertyDefinition(name=\"email\", data_type=PropertyDataType.TEXT),\n                PropertyDefinition(name=\"join_date\", data_type=PropertyDataType.DATETIME),\n                PropertyDefinition(name=\"profile_bio\", data_type=PropertyDataType.TEXT, is_nullable=True),\n            ]\n        )\n        gz.create_object_type(user_type_def)\n        print(\"Created 'User' object type for upsert example.\")\n\n    # Create a new user object\n    new_user_data = {\n        \"user_id\": \"usr_\" + uuid.uuid4().hex[:8], # Domain-specific ID\n        \"username\": \"jdoe\",\n        \"email\": \"jdoe@example.com\",\n        \"join_date\": datetime.now(timezone.utc),\n        \"profile_bio\": \"Loves hiking and coding.\"\n    }\n    new_user_instance = ObjectInstance(\n        object_type_name=\"User\",\n        properties=new_user_data,\n        weight=5.0 # Custom weight\n    )\n\n    try:\n        created_user = gz.upsert_object(new_user_instance)\n        print(f\"User '{created_user.properties['username']}' (ID: {created_user.id}) upserted successfully.\")\n        print(f\"  Upsert Date: {created_user.upsert_date}, Weight: {created_user.weight}\")\n\n        # Update the user's email (upsert again using the system ID)\n        created_user.properties[\"email\"] = \"john.doe.updated@example.com\"\n        created_user.weight = 5.5 # Update weight\n        # Note: upsert_date will be updated automatically by the system on upsert\n\n        updated_user = gz.upsert_object(created_user) # Pass the whole instance with its ID\n        print(f\"User '{updated_user.properties['username']}' (ID: {updated_user.id}) updated successfully.\")\n        print(f\"  New Email: {updated_user.properties['email']}\")\n        print(f\"  Updated Upsert Date: {updated_user.upsert_date}, New Weight: {updated_user.weight}\")\n\n    except Exception as e:\n        print(f\"Error upserting user: {e}\")\n</code></pre>"},{"location":"python_api_detailed/#get_object_by_idobject_id-str-type_name-str-optionalobjectinstance","title":"<code>get_object_by_id(object_id: str, type_name: str) -&gt; Optional[ObjectInstance]</code>","text":"<ul> <li>Signature: <code>def get_object_by_id(self, object_id: str, type_name: str) -&gt; Optional[ObjectInstance]:</code></li> <li>Purpose: Retrieves a specific object instance by its system-generated <code>id</code> and its type name.</li> <li>Example:</li> </ul> <pre><code># Assuming 'gz' is an active Grizabella client and 'created_user' from previous example\n# For this example, let's re-fetch the user created above.\nwith Grizabella(db_name_or_path=\"user_guide_db\") as gz:\n    # First, let's find an existing user to get its ID\n    users = gz.find_objects(type_name=\"User\", filter_criteria={\"username\": \"jdoe\"}, limit=1)\n    if users:\n        user_to_get_id = users[0].id\n        user_type_name = \"User\"\n\n        retrieved_object = gz.get_object_by_id(object_id=str(user_to_get_id), type_name=user_type_name)\n        if retrieved_object:\n            print(f\"Retrieved object by ID '{user_to_get_id}':\")\n            print(f\"  Type: {retrieved_object.object_type_name}\")\n            print(f\"  Properties: {retrieved_object.properties}\")\n            print(f\"  Weight: {retrieved_object.weight}, Upsert Date: {retrieved_object.upsert_date}\")\n        else:\n            print(f\"Object with ID '{user_to_get_id}' of type '{user_type_name}' not found.\")\n    else:\n        print(\"No user 'jdoe' found to get ID for example.\")\n\n</code></pre>"},{"location":"python_api_detailed/#delete_objectobject_id-str-type_name-str-bool","title":"<code>delete_object(object_id: str, type_name: str) -&gt; bool</code>","text":"<ul> <li>Signature: <code>def delete_object(self, object_id: str, type_name: str) -&gt; bool:</code></li> <li>Purpose: Deletes an object instance by its system-generated <code>id</code> and type name.</li> <li>Example:</li> </ul> <pre><code># Assuming 'gz' is an active Grizabella client\n# Let's create a temporary object to delete\nwith Grizabella(db_name_or_path=\"user_guide_db\") as gz:\n    temp_obj_props = {\"user_id\": \"temp_del_user\", \"username\": \"tempdelete\"}\n    temp_obj = ObjectInstance(object_type_name=\"User\", properties=temp_obj_props)\n    created_temp_obj = gz.upsert_object(temp_obj)\n    print(f\"Created temporary object with ID '{created_temp_obj.id}' for deletion.\")\n\n    object_to_delete_id = str(created_temp_obj.id)\n    object_type_name = \"User\"\n\n    try:\n        deleted = gz.delete_object(object_id=object_to_delete_id, type_name=object_type_name)\n        if deleted:\n            print(f\"Object with ID '{object_to_delete_id}' of type '{object_type_name}' deleted successfully.\")\n        else:\n            print(f\"Object with ID '{object_to_delete_id}' not found or not deleted.\")\n    except Exception as e:\n        print(f\"Error deleting object: {e}\")\n</code></pre>"},{"location":"python_api_detailed/#relation-instance-management","title":"Relation Instance Management","text":""},{"location":"python_api_detailed/#add_relationrelation-relationinstance-relationinstance","title":"<code>add_relation(relation: RelationInstance) -&gt; RelationInstance</code>","text":"<ul> <li>Signature: <code>def add_relation(self, relation: RelationInstance) -&gt; RelationInstance:</code></li> <li>Purpose: Adds a new relation instance or updates an existing one if the provided <code>RelationInstance</code> object includes an <code>id</code> that matches an existing relation. The <code>upsert_date</code> metadata field is automatically updated upon creation or update. The <code>weight</code> field can be set or defaults to 1.0. This method effectively performs an \"upsert\" operation for relations.</li> <li>Example:</li> </ul> <pre><code>import uuid\nfrom datetime import datetime, timezone\nfrom grizabella import Grizabella\nfrom grizabella.core.models import (\n    ObjectInstance, RelationInstance,\n    ObjectTypeDefinition, RelationTypeDefinition,\n    PropertyDefinition, PropertyDataType\n)\n\nwith Grizabella(db_name_or_path=\"user_guide_db\") as gz:\n    # 1. Ensure Object Types (\"User\", \"Post\") and Relation Type (\"AUTHORED\") exist\n    if not gz.get_object_type_definition(\"User\"):\n        gz.create_object_type(ObjectTypeDefinition(name=\"User\", properties=[PropertyDefinition(name=\"user_id\", data_type=PropertyDataType.TEXT, is_primary_key=True)]))\n    if not gz.get_object_type_definition(\"Post\"):\n        gz.create_object_type(ObjectTypeDefinition(name=\"Post\", properties=[PropertyDefinition(name=\"post_id\", data_type=PropertyDataType.TEXT, is_primary_key=True), PropertyDefinition(name=\"title\", data_type=PropertyDataType.TEXT)]))\n    if not gz.get_relation_type(\"AUTHORED\"):\n        gz.create_relation_type(RelationTypeDefinition(name=\"AUTHORED\", source_object_type_names=[\"User\"], target_object_type_names=[\"Post\"], properties=[PropertyDefinition(name=\"authored_date\", data_type=PropertyDataType.DATETIME)]))\n    print(\"Ensured types for relation example.\")\n\n    # 2. Create source and target ObjectInstances\n    author_obj = gz.upsert_object(ObjectInstance(object_type_name=\"User\", properties={\"user_id\": \"author_\" + uuid.uuid4().hex[:4]}))\n    post_obj = gz.upsert_object(ObjectInstance(object_type_name=\"Post\", properties={\"post_id\": \"post_\" + uuid.uuid4().hex[:4], \"title\": \"My First Post\"}))\n    print(f\"Created author (ID: {author_obj.id}) and post (ID: {post_obj.id}).\")\n\n    # 3. Create the RelationInstance\n    authored_relation = RelationInstance(\n        relation_type_name=\"AUTHORED\",\n        source_object_instance_id=author_obj.id,\n        target_object_instance_id=post_obj.id,\n        properties={\"authored_date\": datetime.now(timezone.utc)},\n        weight=2.5 # Custom weight for the relation\n    )\n\n    try:\n        created_relation = gz.add_relation(authored_relation)\n        print(f\"Relation '{created_relation.relation_type_name}' (ID: {created_relation.id}) added successfully.\")\n        print(f\"  From: {created_relation.source_object_instance_id}\")\n        print(f\"  To:   {created_relation.target_object_instance_id}\")\n        print(f\"  Properties: {created_relation.properties}\")\n        print(f\"  Weight: {created_relation.weight}, Upsert Date: {created_relation.upsert_date}\")\n    except Exception as e:\n        print(f\"Error adding relation: {e}\")\n</code></pre>"},{"location":"python_api_detailed/#get_relation-and-delete_relation","title":"<code>get_relation(...)</code> and <code>delete_relation(...)</code>","text":"<ul> <li>Note: As per the <code>grizabella.api.client</code> source, <code>get_relation</code> and <code>delete_relation</code> methods that take <code>from_object_id</code>, <code>to_object_id</code>, and <code>relation_type_name</code> are currently marked as <code>NotImplementedError</code>. The underlying DB manager expects a <code>relation_id</code>.     For now, to manage relations by ID, you would typically:<ol> <li>Find relations using <code>get_outgoing_relations</code> or <code>get_incoming_relations</code>.</li> <li>Identify the specific <code>RelationInstance</code> and use its <code>id</code> with the underlying <code>_db_manager</code> methods (though direct <code>_db_manager</code> access is not the public API). This section will be updated if the public API for <code>get_relation</code> and <code>delete_relation</code> by ID or by source/target/type is fully implemented.</li> </ol> </li> </ul>"},{"location":"python_api_detailed/#get_outgoing_relationsobject_id-str-type_name-str-relation_type_name-optionalstr-none-listrelationinstance","title":"<code>get_outgoing_relations(object_id: str, type_name: str, relation_type_name: Optional[str] = None) -&gt; List[RelationInstance]</code>","text":"<ul> <li>Signature: <code>def get_outgoing_relations(self, object_id: str, type_name: str, relation_type_name: Optional[str] = None) -&gt; List[RelationInstance]:</code></li> <li>Purpose: Retrieves all outgoing relations from a given object.</li> <li>Example:</li> </ul> <pre><code># Assuming 'gz' is an active Grizabella client and 'author_obj' from previous example\nwith Grizabella(db_name_or_path=\"user_guide_db\") as gz:\n    # Find an author to get their outgoing relations\n    authors = gz.find_objects(type_name=\"User\", limit=1) # Get any user\n    if authors:\n        author_to_query_id = str(authors[0].id)\n        author_type_name = \"User\" # Type name of the source object\n\n        outgoing_relations = gz.get_outgoing_relations(\n            object_id=author_to_query_id,\n            type_name=author_type_name, # type_name of the source object_id\n            relation_type_name=\"AUTHORED\" # Optional: filter by relation type\n        )\n\n        if outgoing_relations:\n            print(f\"Outgoing 'AUTHORED' relations for object ID '{author_to_query_id}':\")\n            for rel in outgoing_relations:\n                print(f\"  - Relation ID: {rel.id}, Target ID: {rel.target_object_instance_id}, Props: {rel.properties}\")\n        else:\n            print(f\"No outgoing 'AUTHORED' relations found for object ID '{author_to_query_id}'.\")\n    else:\n        print(\"No author found to query outgoing relations.\")\n</code></pre>"},{"location":"python_api_detailed/#get_incoming_relationsobject_id-str-type_name-str-relation_type_name-optionalstr-none-listrelationinstance","title":"<code>get_incoming_relations(object_id: str, type_name: str, relation_type_name: Optional[str] = None) -&gt; List[RelationInstance]</code>","text":"<ul> <li>Signature: <code>def get_incoming_relations(self, object_id: str, type_name: str, relation_type_name: Optional[str] = None) -&gt; List[RelationInstance]:</code></li> <li>Purpose: Retrieves all incoming relations to a given object.</li> <li>Example:</li> </ul> <pre><code># Assuming 'gz' is an active Grizabella client and 'post_obj' from a previous example\nwith Grizabella(db_name_or_path=\"user_guide_db\") as gz:\n    # Find a post to get its incoming relations\n    posts = gz.find_objects(type_name=\"Post\", limit=1) # Get any post\n    if posts:\n        post_to_query_id = str(posts[0].id)\n        post_type_name = \"Post\" # Type name of the target object\n\n        incoming_relations = gz.get_incoming_relations(\n            object_id=post_to_query_id,\n            type_name=post_type_name, # type_name of the target object_id\n            relation_type_name=\"AUTHORED\" # Optional: filter by relation type\n        )\n\n        if incoming_relations:\n            print(f\"Incoming 'AUTHORED' relations for object ID '{post_to_query_id}':\")\n            for rel in incoming_relations:\n                print(f\"  - Relation ID: {rel.id}, Source ID: {rel.source_object_instance_id}, Props: {rel.properties}\")\n        else:\n            print(f\"No incoming 'AUTHORED' relations found for object ID '{post_to_query_id}'.\")\n    else:\n        print(\"No post found to query incoming relations.\")\n\n</code></pre>"},{"location":"python_api_detailed/#querying","title":"Querying","text":"<p>Grizabella provides several ways to query your data, from simple object lookups to complex multi-faceted queries.</p>"},{"location":"python_api_detailed/#simple-object-queries-find_objects","title":"Simple Object Queries (<code>find_objects</code>)","text":"<ul> <li>Signature: <code>def find_objects(self, type_name: str, filter_criteria: Optional[Dict[str, Any]] = None, limit: Optional[int] = None) -&gt; List[ObjectInstance]:</code></li> <li>Note: The client API uses <code>find_objects</code>. The prompt mentioned <code>query_objects</code>. We'll document <code>find_objects</code> as it's in the client.</li> <li>Purpose: Finds objects of a given type, optionally matching filter criteria on their properties.</li> <li> <p>Examples:</p> </li> <li> <p>Filtering with simple equality:</p> <p>```python</p> </li> <li> <p>Using <code>limit</code>: (Offset is not directly supported by <code>find_objects</code>, but by <code>query_object_instances</code> in DBManager)</p> <p>```python</p> </li> <li> <p>The <code>filter_criteria</code> currently supports exact matches. For more complex conditions (e.g., &gt;, &lt;, LIKE), you would typically use the <code>execute_complex_query</code> method or if the underlying <code>query_object_instances</code> in <code>DBManager</code> evolves to support richer conditions directly through <code>find_objects</code>.</p> </li> </ul>"},{"location":"python_api_detailed/#assuming-gz-is-an-active-grizabella-client","title":"Assuming 'gz' is an active Grizabella client","text":"<p>with Grizabella(db_name_or_path=\"user_guide_db\") as gz:     # Find all active users named \"jdoe\"     active_jdoes = gz.find_objects(         type_name=\"User\",         filter_criteria={\"username\": \"jdoe\", \"is_active\": True} # Assuming 'is_active' property exists     )     if active_jdoes:         print(f\"Found {len(active_jdoes)} active user(s) named 'jdoe':\")         for user in active_jdoes:             print(f\"  - ID: {user.id}, Email: {user.properties.get('email')}\")     else:         print(\"No active users named 'jdoe' found.\") ```</p>"},{"location":"python_api_detailed/#assuming-gz-is-an-active-grizabella-client_1","title":"Assuming 'gz' is an active Grizabella client","text":"<p>with Grizabella(db_name_or_path=\"user_guide_db\") as gz:     # Get up to 5 posts (any posts)     latest_posts = gz.find_objects(type_name=\"Post\", limit=5)     if latest_posts:         print(f\"Found {len(latest_posts)} post(s) (limit 5):\")         for post in latest_posts:             print(f\"  - ID: {post.id}, Title: {post.properties.get('title')}\")     else:         print(\"No posts found.\") ```</p>"},{"location":"python_api_detailed/#embedding-similarity-search-search_similar_objects","title":"Embedding Similarity Search (<code>search_similar_objects</code>)","text":"<ul> <li>Signature: <code>def search_similar_objects(self, object_id: str, type_name: str, n_results: int = 5, search_properties: Optional[List[str]] = None) -&gt; List[Tuple[ObjectInstance, float]]:</code></li> <li>Purpose: Searches for objects similar to a given object, typically using embeddings.</li> <li> <p>Note: The client API's <code>search_similar_objects</code> is currently marked as <code>NotImplementedError</code> because its signature (taking <code>object_id</code>, <code>type_name</code>) differs from the underlying DBManager's <code>find_similar_objects_by_embedding</code> which expects an <code>embedding_definition_name</code> and a <code>query_vector</code> or <code>query_text</code>.     The examples below are conceptual for how a fully implemented <code>find_similar</code> (as requested in the prompt) might work, assuming it maps to the DBManager's capabilities.</p> <p>Conceptual <code>find_similar</code> (if it were implemented to match DBManager):</p> <p>Let's assume a hypothetical <code>find_similar_by_definition</code> method in the client: <code>def find_similar_by_definition(self, embedding_definition_name: str, query_text: Optional[str] = None, query_vector: Optional[List[float]] = None, limit: int = 5, filter_condition: Optional[Dict[str, Any]] = None, retrieve_full_objects: bool = True) -&gt; List[Tuple[ObjectInstance, float]]:</code></p> </li> <li> <p>Example using <code>query_text</code> (Conceptual):</p> </li> </ul> <pre><code>        # CONCEPTUAL EXAMPLE - Method does not exist with this signature in current client\n        # Assuming 'gz' is an active Grizabella client and \"user_profile_bio_sbert\" embedding def exists\n        # with Grizabella(db_name_or_path=\"user_guide_db\") as gz:\n        #     search_text = \"Looking for software engineers passionate about Python.\"\n        #     try:\n        #         similar_users = gz.find_similar_by_definition( # Hypothetical method\n        #             embedding_definition_name=\"user_profile_bio_sbert\",\n        #             query_text=search_text,\n        #             limit=3\n        #         )\n        #         if similar_users:\n        #             print(f\"Users with bios similar to '{search_text}':\")\n        #             for user, score in similar_users:\n        #                 print(f\"  - ID: {user.id}, Username: {user.properties.get('username')}, Score: {score:.4f}\")\n        #                 print(f\"    Bio: {user.properties.get('profile_bio')[:100]}...\") # Show part of bio\n        #         else:\n        #             print(\"No similar users found.\")\n        #     except Exception as e:\n        #         print(f\"Error during conceptual similarity search: {e}\")\n</code></pre> <ul> <li>Example using <code>query_vector</code> (Conceptual):</li> </ul> <pre><code>        # CONCEPTUAL EXAMPLE\n        # import numpy as np # For generating a dummy vector\n        # with Grizabella(db_name_or_path=\"user_guide_db\") as gz:\n        #     # Assume 'user_profile_bio_sbert' has dimensions 384\n        #     dummy_vector = np.random.rand(384).tolist()\n        #     try:\n        #         similar_users_by_vector = gz.find_similar_by_definition( # Hypothetical method\n        #             embedding_definition_name=\"user_profile_bio_sbert\",\n        #             query_vector=dummy_vector,\n        #             limit=2\n        #         )\n        #         if similar_users_by_vector:\n        #             print(\"Users similar to the provided vector:\")\n        #             for user, score in similar_users_by_vector:\n        #                 print(f\"  - ID: {user.id}, Score: {score:.4f}\")\n        #         else:\n        #             print(\"No users found similar to the vector.\")\n        #     except Exception as e:\n        #         print(f\"Error during conceptual vector similarity search: {e}\")\n</code></pre> <ul> <li>Example with <code>limit</code> and <code>filter_condition</code> (Conceptual):         The <code>filter_condition</code> would likely be a dictionary similar to <code>find_objects</code>' <code>filter_criteria</code>, applied after the similarity search to the candidate objects, or potentially pushed down to the vector DB if supported.         The <code>retrieve_full_objects</code> parameter (boolean) would control whether the full <code>ObjectInstance</code> is returned or perhaps just IDs and scores.</li> </ul>"},{"location":"python_api_detailed/#complex-queries-execute_complex_query","title":"Complex Queries (<code>execute_complex_query</code>)","text":"<ul> <li>Signature: <code>def execute_complex_query(self, query: ComplexQuery) -&gt; QueryResult:</code></li> <li>Purpose: Executes a sophisticated query that can combine relational filters, graph traversals, and embedding searches across multiple object types and database layers.</li> <li>Pydantic Models: Uses <code>ComplexQuery</code>, <code>QueryComponent</code>, <code>RelationalFilter</code>, <code>EmbeddingSearchClause</code>, <code>GraphTraversalClause</code> from <code>grizabella.core.query_models</code>.</li> <li> <p>Example 1: Find active users who authored posts about \"Python\"</p> <p>```python from grizabella import Grizabella from grizabella.core.query_models import (     ComplexQuery, QueryComponent, RelationalFilter, GraphTraversalClause )</p> </li> <li> <p>Example 2: \"CAR\" example - Find \"Car\" objects that are \"Red\" and \"LocatedIn\" a \"City\" named \"Testville\" and have a \"HAS_PART\" relation to a \"Part\" object whose \"part_name\" is \"EngineV8\".</p> <p>```python</p> </li> </ul> <p>This detailed guide should help you effectively use the Grizabella Python API. Remember to consult the specific docstrings in the source code for the most up-to-date details on parameters and behavior.</p>"},{"location":"python_api_detailed/#assume-objecttypes-user-username-is_active-post-title-content","title":"Assume ObjectTypes: User (username, is_active), Post (title, content)","text":""},{"location":"python_api_detailed/#assume-relationtype-authored-user-post","title":"Assume RelationType: AUTHORED (User -&gt; Post)","text":""},{"location":"python_api_detailed/#assume-embeddingdefinition-post_content_embed-on-postcontent","title":"Assume EmbeddingDefinition: post_content_embed (on Post.content)","text":""},{"location":"python_api_detailed/#this-example-requires-an-embedding-vector-for-python","title":"This example requires an embedding vector for \"Python\".","text":""},{"location":"python_api_detailed/#in-a-real-scenario-youd-generate-this-using-the-same-model-as-post_content_embed","title":"In a real scenario, you'd generate this using the same model as 'post_content_embed'.","text":""},{"location":"python_api_detailed/#for-this-example-well-use-a-relational-filter-on-title-for-simplicity","title":"For this example, we'll use a relational filter on title for simplicity,","text":""},{"location":"python_api_detailed/#as-generating-the-vector-here-is-out-of-scope","title":"as generating the vector here is out of scope.","text":""},{"location":"python_api_detailed/#a-true-embedding-search-would-use-embeddingsearchclause","title":"A true embedding search would use EmbeddingSearchClause.","text":"<p>with Grizabella(db_name_or_path=\"user_guide_db\") as gz:     # Ensure types exist for the example     if not gz.get_object_type_definition(\"User\"):         gz.create_object_type(ObjectTypeDefinition(name=\"User\", properties=[             PropertyDefinition(name=\"user_id\", data_type=PropertyDataType.TEXT, is_primary_key=True),             PropertyDefinition(name=\"username\", data_type=PropertyDataType.TEXT),             PropertyDefinition(name=\"is_active\", data_type=PropertyDataType.BOOLEAN, default=True)         ]))     if not gz.get_object_type_definition(\"Post\"):         gz.create_object_type(ObjectTypeDefinition(name=\"Post\", properties=[             PropertyDefinition(name=\"post_id\", data_type=PropertyDataType.TEXT, is_primary_key=True),             PropertyDefinition(name=\"title\", data_type=PropertyDataType.TEXT, is_indexed=True),             PropertyDefinition(name=\"content\", data_type=PropertyDataType.TEXT)         ]))     if not gz.get_relation_type(\"AUTHORED\"):         gz.create_relation_type(RelationTypeDefinition(name=\"AUTHORED\", source_object_type_names=[\"User\"], target_object_type_names=[\"Post\"]))     print(\"Ensured types for complex query example 1.\")</p> <pre><code># Create some sample data\nactive_user = gz.upsert_object(ObjectInstance(object_type_name=\"User\", properties={\"user_id\": \"user_cq1\", \"username\": \"coder1\", \"is_active\": True}))\ninactive_user = gz.upsert_object(ObjectInstance(object_type_name=\"User\", properties={\"user_id\": \"user_cq2\", \"username\": \"coder2\", \"is_active\": False}))\npython_post = gz.upsert_object(ObjectInstance(object_type_name=\"Post\", properties={\"post_id\": \"post_cq1\", \"title\": \"Intro to Python\", \"content\": \"Python is great.\"}))\njava_post = gz.upsert_object(ObjectInstance(object_type_name=\"Post\", properties={\"post_id\": \"post_cq2\", \"title\": \"Java Basics\", \"content\": \"Java is also cool.\"}))\n\ngz.add_relation(RelationInstance(relation_type_name=\"AUTHORED\", source_object_instance_id=active_user.id, target_object_instance_id=python_post.id))\ngz.add_relation(RelationInstance(relation_type_name=\"AUTHORED\", source_object_instance_id=inactive_user.id, target_object_instance_id=java_post.id))\ngz.add_relation(RelationInstance(relation_type_name=\"AUTHORED\", source_object_instance_id=active_user.id, target_object_instance_id=java_post.id)) # Active user also wrote a Java post\nprint(\"Added sample data for complex query example 1.\")\n\ncomplex_query_def = ComplexQuery(\n    description=\"Find active users who authored posts with 'Python' in the title.\",\n    components=[\n        QueryComponent(\n            object_type_name=\"User\", # Start with Users\n            relational_filters=[\n                RelationalFilter(property_name=\"is_active\", operator=\"==\", value=True)\n            ],\n            graph_traversals=[\n                GraphTraversalClause(\n                    relation_type_name=\"AUTHORED\",\n                    direction=\"outgoing\",\n                    target_object_type_name=\"Post\",\n                    target_object_properties=[ # Filter on properties of the target \"Post\" objects\n                        RelationalFilter(property_name=\"title\", operator=\"CONTAINS\", value=\"Python\")\n                    ]\n                )\n            ]\n        )\n    ]\n)\n\ntry:\n    query_result = gz.execute_complex_query(complex_query_def)\n    if query_result.errors:\n        print(f\"Errors during complex query: {query_result.errors}\")\n\n    if query_result.object_instances:\n        print(\"Users matching the complex query:\")\n        for obj_instance in query_result.object_instances:\n            # The result instances are of the primary object_type_name of the first component, \"User\"\n            print(f\"  - User ID: {obj_instance.id}, Username: {obj_instance.properties.get('username')}\")\n    else:\n        print(\"No users found matching the complex query.\")\nexcept NotImplementedError:\n    print(\"execute_complex_query or its underlying DBManager.process_complex_query is not fully implemented.\")\nexcept Exception as e:\n    print(f\"An error occurred executing complex query: {e}\")\n</code></pre> <p>```</p>"},{"location":"python_api_detailed/#assuming-objecttypes-carcolor-cityname-partpart_name","title":"Assuming ObjectTypes: Car(color), City(name), Part(part_name)","text":""},{"location":"python_api_detailed/#assuming-relationtypes-locatedin-car-city-has_part-car-part","title":"Assuming RelationTypes: LocatedIn (Car -&gt; City), HAS_PART (Car -&gt; Part)","text":"<p>with Grizabella(db_name_or_path=\"user_guide_db\") as gz:     # Setup (ensure types and some data exist)     for ot_name, props in [(\"Car\", [(\"color\", PropertyDataType.TEXT)]), (\"City\", [(\"name\", PropertyDataType.TEXT)]), (\"Part\", [(\"part_name\", PropertyDataType.TEXT)])]:         if not gz.get_object_type_definition(ot_name):             gz.create_object_type(ObjectTypeDefinition(name=ot_name, properties=[PropertyDefinition(name=p[0], data_type=p[1]) for p in props]))     for rt_name, src, tgt in [(\"LocatedIn\", \"Car\", \"City\"), (\"HAS_PART\", \"Car\", \"Part\")]:         if not gz.get_relation_type(rt_name):             gz.create_relation_type(RelationTypeDefinition(name=rt_name, source_object_type_names=[src], target_object_type_names=[tgt]))     print(\"Ensured types for CAR complex query example.\")</p> <pre><code># Sample Data\nred_car1 = gz.upsert_object(ObjectInstance(object_type_name=\"Car\", properties={\"color\": \"Red\"}))\nblue_car = gz.upsert_object(ObjectInstance(object_type_name=\"Car\", properties={\"color\": \"Blue\"}))\ntestville = gz.upsert_object(ObjectInstance(object_type_name=\"City\", properties={\"name\": \"Testville\"}))\notherville = gz.upsert_object(ObjectInstance(object_type_name=\"City\", properties={\"name\": \"Otherville\"}))\nengine_v8 = gz.upsert_object(ObjectInstance(object_type_name=\"Part\", properties={\"part_name\": \"EngineV8\"}))\nengine_v6 = gz.upsert_object(ObjectInstance(object_type_name=\"Part\", properties={\"part_name\": \"EngineV6\"}))\n\ngz.add_relation(RelationInstance(relation_type_name=\"LocatedIn\", source_object_instance_id=red_car1.id, target_object_instance_id=testville.id))\ngz.add_relation(RelationInstance(relation_type_name=\"LocatedIn\", source_object_instance_id=blue_car.id, target_object_instance_id=testville.id))\ngz.add_relation(RelationInstance(relation_type_name=\"HAS_PART\", source_object_instance_id=red_car1.id, target_object_instance_id=engine_v8.id))\ngz.add_relation(RelationInstance(relation_type_name=\"HAS_PART\", source_object_instance_id=blue_car.id, target_object_instance_id=engine_v6.id))\nprint(\"Added sample data for CAR complex query example.\")\n\ncar_query = ComplexQuery(\n    description=\"Find Red Cars in Testville with a V8 Engine.\",\n    components=[\n        QueryComponent(\n            object_type_name=\"Car\",\n            relational_filters=[\n                RelationalFilter(property_name=\"color\", operator=\"==\", value=\"Red\")\n            ],\n            graph_traversals=[\n                GraphTraversalClause( # Car --LocatedIn--&gt; City\n                    relation_type_name=\"LocatedIn\",\n                    direction=\"outgoing\",\n                    target_object_type_name=\"City\",\n                    target_object_properties=[\n                        RelationalFilter(property_name=\"name\", operator=\"==\", value=\"Testville\")\n                    ]\n                ),\n                GraphTraversalClause( # Car --HAS_PART--&gt; Part\n                    relation_type_name=\"HAS_PART\",\n                    direction=\"outgoing\",\n                    target_object_type_name=\"Part\",\n                    target_object_properties=[\n                        RelationalFilter(property_name=\"part_name\", operator=\"==\", value=\"EngineV8\")\n                    ]\n                )\n            ]\n        )\n    ]\n)\ntry:\n    car_query_result = gz.execute_complex_query(car_query)\n    if car_query_result.errors:\n        print(f\"Errors during CAR complex query: {car_query_result.errors}\")\n\n    if car_query_result.object_instances:\n        print(\"Cars matching the CAR complex query:\")\n        for car in car_query_result.object_instances:\n            print(f\"  - Car ID: {car.id}, Color: {car.properties.get('color')}\")\n    else:\n        print(\"No cars found matching the CAR complex query.\")\nexcept NotImplementedError:\n    print(\"execute_complex_query or its underlying DBManager.process_complex_query is not fully implemented.\")\nexcept Exception as e:\n    print(f\"An error occurred executing CAR complex query: {e}\")\n</code></pre> <p>```</p> <p>Interpreting <code>QueryResult</code>: The <code>QueryResult</code> object contains:   * <code>object_instances</code>: A list of <code>ObjectInstance</code>s that match the entire complex query. These instances will be of the <code>object_type_name</code> specified in the first component of your <code>ComplexQuery</code> if not otherwise specified by future features like explicit return types.   * <code>errors</code>: A list of strings, containing any error messages encountered during query planning or execution. Check this list to debug issues.</p>"},{"location":"troubleshooting_faq/","title":"Troubleshooting &amp; FAQ","text":"<p>This section provides solutions to common problems and answers to frequently asked questions about Grizabella.</p>"},{"location":"troubleshooting_faq/#troubleshooting","title":"Troubleshooting","text":""},{"location":"troubleshooting_faq/#installation-issues","title":"Installation Issues","text":"<ul> <li>Common problems with <code>poetry install</code>:</li> <li>Ensure you have Poetry installed correctly. Refer to the official Poetry documentation.</li> <li>Make sure your <code>pyproject.toml</code> file is not corrupted and all dependencies are resolvable.</li> <li>Try running <code>poetry lock --no-update</code> and then <code>poetry install</code> if you suspect a lock file issue.</li> <li> <p>Check for network connectivity issues if packages fail to download.</p> </li> <li> <p>Missing Arrow C++ libraries for <code>lancedb</code>:</p> </li> <li>Grizabella uses <code>lancedb</code>, which in turn requires Apache Arrow C++ libraries.</li> <li>On Debian/Ubuntu, install them using: <code>sudo apt-get install -y libarrow-dev</code></li> <li>On other systems, refer to the Apache Arrow installation guide for installing the C++ libraries.</li> <li> <p>Alternatively, you might be able to install a pre-built <code>pyarrow</code> wheel that includes these, but system-wide installation is often more reliable for <code>lancedb</code>.</p> </li> <li> <p>Python version incompatibilities:</p> </li> <li>Grizabella is developed and tested with Python 3.9+. Using older versions might lead to unexpected errors.</li> <li>Ensure your Poetry environment is configured to use a compatible Python version. You can specify this in your <code>pyproject.toml</code> or when creating the environment with <code>poetry env use &lt;python_version&gt;</code>.</li> </ul>"},{"location":"troubleshooting_faq/#connection-issues-uiapi","title":"Connection Issues (UI/API)","text":"<ul> <li>\"Cannot connect to database\" / Default database not found:</li> <li>Check Path: Verify that the database path specified (or the default path <code>~/.grizabella/default_db</code>) exists and is accessible.</li> <li>Permissions: Ensure Grizabella has read/write permissions for the database directory and its files.</li> <li>Default Database: If you haven't specified a custom path, Grizabella looks for a database at <code>~/.grizabella/default_db</code>. If this is your first time running Grizabella or if this directory was removed, it might not exist. The application should create it on first valid schema definition, but if you encounter issues, ensure the parent directory <code>~/.grizabella</code> is writable.</li> </ul>"},{"location":"troubleshooting_faq/#schema-definition-errors","title":"Schema Definition Errors","text":"<ul> <li>Common mistakes when defining <code>ObjectTypeDefinition</code>, <code>EmbeddingDefinition</code>, <code>RelationTypeDefinition</code>:</li> <li>Referencing non-existent types: Ensure that any <code>ObjectType</code> referenced in a <code>RelationTypeDefinition</code> (as <code>from_type</code> or <code>to_type</code>) or in an <code>EmbeddingDefinition</code> (as <code>object_type_name</code>) has already been defined.</li> <li>Incorrect property types: Property types in <code>ObjectTypeDefinition</code> must be valid Python types (e.g., <code>str</code>, <code>int</code>, <code>float</code>, <code>bool</code>, <code>list</code>, <code>dict</code>) or Pydantic models.</li> <li>Naming conventions: While not strictly errors, adhere to consistent naming for clarity.</li> <li>Embedding source fields: Ensure the <code>source_fields</code> in an <code>EmbeddingDefinition</code> exist as properties in the corresponding <code>ObjectTypeDefinition</code>.</li> </ul>"},{"location":"troubleshooting_faq/#embedding-generation-failures","title":"Embedding Generation Failures","text":"<ul> <li>SentenceTransformer model download issues:</li> <li>Network: Check your internet connection. SentenceTransformer models are downloaded from Hugging Face Hub.</li> <li>Model name typo: Verify the model identifier (e.g., <code>all-MiniLM-L6-v2</code>) is correct. A typo will prevent the model from being found.</li> <li> <p>Firewall/Proxy: If you are behind a corporate firewall or proxy, ensure it allows connections to Hugging Face.</p> </li> <li> <p>Dimension mismatches:</p> </li> <li>If you are using pre-computed embeddings or a custom model, ensure the embedding dimensions match what <code>lancedb</code> expects or what your downstream tasks require. The default models have specific output dimensions.</li> </ul>"},{"location":"troubleshooting_faq/#query-issues","title":"Query Issues","text":"<ul> <li>Complex query JSON parsing errors (UI input):</li> <li>If inputting complex queries directly as JSON in the UI (if such a feature is available), ensure the JSON is well-formed. Validate it with a JSON linter.</li> <li> <p>Pay attention to quotes, commas, and brackets.</p> </li> <li> <p>No results returned:</p> </li> <li>Check filters: Ensure your query filters are not too restrictive or unintentionally excluding all data.</li> <li>Data existence: Verify that data matching your query criteria actually exists in the database.</li> <li>Embedding similarity: If performing a vector search, the query vector might not be similar enough to any stored embeddings. Try broadening the search or using a more general query.</li> <li>Case sensitivity: Some text-based filters might be case-sensitive by default.</li> </ul>"},{"location":"troubleshooting_faq/#faq-frequently-asked-questions","title":"FAQ (Frequently Asked Questions)","text":"<ul> <li>Q: How do I specify a custom database location?</li> <li> <p>A: You can set the <code>GRIZABELLA_DB_PATH</code> environment variable to your desired directory path before launching Grizabella. Alternatively, some Grizabella components or the API client might allow specifying the path programmatically.</p> </li> <li> <p>Q: What embedding models are supported?</p> </li> <li> <p>A: By default, Grizabella is configured to use a model like <code>Colbert</code> (or a similar high-quality SentenceTransformer model). However, you can specify any SentenceTransformer model identifier from the Hugging Face Hub when defining an <code>EmbeddingDefinition</code>. Grizabella will then attempt to download and use that model.</p> </li> <li> <p>Q: Can I have multiple embedding definitions for the same object type?</p> </li> <li> <p>A: Yes. You can define multiple <code>EmbeddingDefinition</code>s for a single <code>ObjectType</code>. Each definition can use different source fields and/or a different embedding model, allowing for diverse semantic representations of your objects.</p> </li> <li> <p>Q: How is data consistency maintained across the three layers (SQLite, LanceDB, K\u00f9zu)?</p> </li> <li> <p>A: The Grizabella API and its core <code>DBManager</code> orchestrate operations across the different database layers. When an object is created, updated, or deleted, <code>DBManager</code> ensures that corresponding changes are made in the structured data store (SQLite), the vector store (LanceDB for embeddings), and the graph store (K\u00f9zu for relations) as needed, based on your schema definitions.</p> </li> <li> <p>Q: Where can I report bugs or ask for help?</p> </li> <li>A: Please report bugs, suggest features, or ask for help by creating an issue on our GitHub repository: <code>https://github.com/pwilkin/grizabella/issues</code> (Note: This is a placeholder URL).</li> </ul>"},{"location":"troubleshooting_faq/#connection-management-best-practices","title":"Connection Management Best Practices","text":""},{"location":"troubleshooting_faq/#resource-management","title":"Resource Management","text":"<ul> <li>Always use context managers or proper cleanup:</li> <li> <p>When using the Python API, use the <code>with</code> statement or explicitly call cleanup methods to ensure resources are properly released:     ```python     from grizabella.api.client import Grizabella</p> </li> <li> <p>Connection pooling:</p> </li> <li>Grizabella implements connection pooling to efficiently manage database connections.</li> <li>The connection pool automatically manages idle connections and cleans them up after a configurable timeout period.</li> <li> <p>Connection pools are shared across managers for the same database type and path.</p> </li> <li> <p>Singleton pattern for DB managers:</p> </li> <li>DB managers are implemented using a singleton pattern with reference counting.</li> <li>Multiple requests for the same database path will return the same manager instance.</li> <li>Managers are automatically cleaned up when all references are released.</li> </ul>"},{"location":"troubleshooting_faq/#recommended-approach-using-context-manager","title":"Recommended approach using context manager","text":"<p>with Grizabella(db_name_or_path=\"my_db\") as client:     # Perform operations     client.create_object_type(...)     # Resources automatically cleaned up when exiting the context ```   * For long-running applications, ensure to call cleanup methods explicitly when shutting down.</p>"},{"location":"troubleshooting_faq/#memory-management","title":"Memory Management","text":"<ul> <li>Preventing memory leaks:</li> <li>Always release DB managers when no longer needed by calling the appropriate cleanup methods.</li> <li>The system implements automatic cleanup on process shutdown, but explicit cleanup is recommended.</li> <li> <p>Monitor memory usage during long-running operations to detect potential leaks early.</p> </li> <li> <p>Resource monitoring:</p> </li> <li>Grizabella includes a resource monitoring dashboard accessible via the web interface for real-time monitoring of CPU, memory, connections, and threads.</li> <li>Use the monitoring tools to track resource usage patterns and identify potential issues.</li> </ul>"},{"location":"troubleshooting_faq/#threading-and-concurrency","title":"Threading and Concurrency","text":"<ul> <li>Thread-safe operations:</li> <li>Database adapters are designed to be thread-safe, with separate connections per thread for K\u00f9zu adapter.</li> <li> <p>Avoid sharing connection objects across threads directly; use the provided connection management instead.</p> </li> <li> <p>Concurrent access patterns:</p> </li> <li>Multiple threads can safely access the same database through the connection pool.</li> <li>The system handles concurrent access efficiently while maintaining data integrity.</li> </ul>"},{"location":"troubleshooting_faq/#connection-lifecycle","title":"Connection Lifecycle","text":"<ul> <li>Proper initialization:</li> <li>Always initialize the client with appropriate configuration including timeouts and retry settings.</li> <li> <p>Use the factory pattern to create and manage DB managers properly.</p> </li> <li> <p>Graceful shutdown:</p> </li> <li>Implement proper shutdown handlers that clean up all resources.</li> <li>The system includes signal handlers for SIGINT and SIGTERM to ensure graceful shutdown.</li> <li>All connections and resources are automatically cleaned up during shutdown.</li> </ul>"},{"location":"troubleshooting_faq/#troubleshooting-connection-issues","title":"Troubleshooting Connection Issues","text":"<ul> <li>Connection timeouts:</li> <li>If experiencing connection timeouts, increase the timeout values in the configuration.</li> <li> <p>Check if the database files are accessible and not locked by another process.</p> </li> <li> <p>Too many open files:</p> </li> <li>This error indicates that too many connections are being held open simultaneously.</li> <li>Ensure that connections are being properly returned to the pool or closed after use.</li> <li> <p>Consider adjusting the maximum connection pool size if needed for your use case.</p> </li> <li> <p>Database locking issues:</p> </li> <li>SQLite databases can experience locking issues with high concurrent write operations.</li> <li>Consider using appropriate transaction management and connection pooling to reduce lock contention.</li> </ul>"},{"location":"api/client/","title":"API Client","text":""},{"location":"api/client/#grizabella.api.client","title":"<code>grizabella.api.client</code>","text":"<p>Grizabella API Client.</p> <p>This module provides the main Grizabella class, which serves as the public API for interacting with the Grizabella data store.</p>"},{"location":"api/client/#grizabella.api.client.Grizabella","title":"<code>Grizabella</code>","text":"<p>Public API for interacting with the Grizabella data store.</p> <p>This class provides a high-level interface to manage and query data within a Grizabella database instance. It handles connection management, schema operations (object and relation types), data manipulation (objects and relations), embedding definitions, and complex queries.</p> <p>Attributes:</p> Name Type Description <code>_db_manager</code> <code>GrizabellaDBManager</code> <p>An instance of the database manager responsible for lower-level database interactions.</p> <code>_is_connected</code> <code>bool</code> <p>Tracks the connection state to the database.</p> Source code in <code>grizabella/api/client.py</code> <pre><code>class Grizabella:\n    \"\"\"Public API for interacting with the Grizabella data store.\n\n    This class provides a high-level interface to manage and query data\n    within a Grizabella database instance. It handles connection management,\n    schema operations (object and relation types), data manipulation (objects\n    and relations), embedding definitions, and complex queries.\n\n    Attributes:\n        _db_manager (GrizabellaDBManager): An instance of the database manager\n            responsible for lower-level database interactions.\n        _is_connected (bool): Tracks the connection state to the database.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        db_name_or_path: Union[str, Path] = \"default\",\n        create_if_not_exists: bool = True,\n    ) -&gt; None:\n        \"\"\"Initializes the Grizabella API client.\n\n        Sets up the connection to the specified Grizabella database. If the\n        database does not exist and `create_if_not_exists` is True, it will\n        be created.\n\n        Args:\n            db_name_or_path (Union[str, Path]): The name of the database or\n                the file system path to the database directory.\n                Defaults to \"default\".\n            create_if_not_exists (bool): If True, the database will be\n                created if it does not already exist. Defaults to True.\n\n        \"\"\"\n        self._logger = logging.getLogger(__name__) # Initialize logger\n        self._initial_db_name_or_path = db_name_or_path # Store the initial path/name\n\n        # Use factory for DBManager to enable singleton pattern and proper lifecycle management\n        self._db_manager_factory = get_db_manager_factory()\n\n        # Check if GrizabellaDBManager has been mocked (for testing)\n        import grizabella.api.client as client_module\n        if hasattr(client_module, 'GrizabellaDBManager') and hasattr(client_module.GrizabellaDBManager, 'return_value'):\n            # If GrizabellaDBManager is a mock, call the constructor to ensure it's tracked by tests\n            # but then use the mock instance for method calls\n            manager_constructor_args = {\n                'db_name_or_path': db_name_or_path,\n                'create_if_not_exists': create_if_not_exists,\n            }\n            # Call the constructor to register the call for test verification\n            client_module.GrizabellaDBManager(**manager_constructor_args)\n            # Use the mock instance for all subsequent operations\n            self._db_manager = client_module.GrizabellaDBManager.return_value\n        else:\n            self._db_manager = self._db_manager_factory.get_manager(\n                db_name_or_path=db_name_or_path,\n                create_if_not_exists=create_if_not_exists,\n            )\n\n        self._is_connected = False\n\n        self._logger.info(f\"Grizabella client initialized for database: {db_name_or_path} using factory pattern\")\n\n    @property\n    def db_name_or_path(self) -&gt; Union[str, Path]:\n        \"\"\"Returns the database name or path this client was initialized with.\"\"\"\n        return self._initial_db_name_or_path\n\n    def connect(self) -&gt; None:\n        \"\"\"Connects to the underlying Grizabella database.\n\n        Establishes a connection to the database if not already connected.\n        This method is typically called automatically when using the client\n        as a context manager or before performing database operations if\n        the connection was previously closed.\n\n        Raises:\n            GrizabellaException: If there is an error connecting to the database.\n\n        \"\"\"\n        if not self._is_connected:\n            self._db_manager.connect()\n            self._is_connected = True\n\n    def close(self) -&gt; None:\n        \"\"\"Closes the connection to the underlying Grizabella database.\n\n        Releases any resources held by the database connection. It's important\n        to close the connection when it's no longer needed, especially if not\n        using the client as a context manager.\n\n        Raises:\n            GrizabellaException: If there is an error closing the database connection.\n\n        \"\"\"\n        self._logger.info(f\"Grizabella client close() called for db: {self.db_name_or_path}. Connected: {self._is_connected}\")\n        if self._is_connected:\n            try:\n                self._db_manager.close() # This should call _ConnectionHelper.close_all_adapters()\n                self._logger.info(f\"Grizabella client: self._db_manager.close() completed for {self.db_name_or_path}.\")\n            except Exception as e:\n                self._logger.error(f\"Grizabella client: Error during self._db_manager.close() for {self.db_name_or_path}: {e}\", exc_info=True)\n            finally:\n                self._is_connected = False\n                self._logger.info(f\"Grizabella client: _is_connected set to False for {self.db_name_or_path}.\")\n        else:\n            self._logger.info(f\"Grizabella client: Already not connected for {self.db_name_or_path}, no action taken in close().\")\n\n    def __enter__(self) -&gt; \"Grizabella\":\n        \"\"\"Context manager entry point. Connects to the database.\n\n        Returns:\n            Grizabella: The Grizabella API client instance.\n\n        \"\"\"\n        self.connect()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: Optional[type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[Any],\n    ) -&gt; None:\n        \"\"\"Context manager exit point. Closes the database connection.\n\n        Args:\n            exc_type: The type of the exception, if any.\n            exc_val: The exception instance, if any.\n            exc_tb: The traceback object, if any.\n\n        \"\"\"\n        self.close()\n\n    # --- Schema Management ---\n    def create_object_type(self, object_type_def: ObjectTypeDefinition) -&gt; None:\n        \"\"\"Creates a new object type in the database.\n\n        Object types define the schema for a category of objects, similar to\n        tables in a relational database or node labels in a graph database.\n\n        Args:\n            object_type_def (ObjectTypeDefinition): The definition of the\n                object type to create, including its name and properties.\n\n        Raises:\n            GrizabellaException: If the object type already exists or if there\n                is an error during creation.\n            NotConnectedError: If the client is not connected to the database.\n\n        \"\"\"\n        self._db_manager.add_object_type_definition(object_type_def)\n\n    def get_object_type_definition(\n        self, type_name: str,\n    ) -&gt; Optional[ObjectTypeDefinition]:\n        \"\"\"Retrieves the definition of an object type.\n\n        Args:\n            type_name (str): The name of the object type to retrieve.\n\n        Returns:\n            Optional[ObjectTypeDefinition]: The definition of the object type\n            if found, otherwise None.\n\n        Raises:\n            NotConnectedError: If the client is not connected to the database.\n\n        \"\"\"\n        return self._db_manager.get_object_type_definition(type_name)\n\n    def list_object_types(self) -&gt; list[ObjectTypeDefinition]:\n        \"\"\"Lists all defined object types in the database.\n\n        Returns:\n            List[ObjectTypeDefinition]: A list of all object type definitions.\n\n        Raises:\n            NotConnectedError: If the client is not connected to the database.\n\n        \"\"\"\n        if not self._is_connected:\n            self._db_manager.connect()  # Ensure connection\n        return self._db_manager.list_object_type_definitions()\n\n    def delete_object_type(self, type_name: str) -&gt; None:\n        \"\"\"Deletes an object type from the database.\n\n        Warning: This operation may also delete all associated object instances\n        and relations, depending on the underlying database implementation and\n        cascade rules.\n\n        Args:\n            type_name (str): The name of the object type to delete.\n\n        Raises:\n            GrizabellaException: If the object type does not exist or if there\n                is an error during deletion.\n            NotConnectedError: If the client is not connected to the database.\n\n        \"\"\"\n        self._db_manager.remove_object_type_definition(type_name)\n\n    def create_relation_type(self, relation_type_def: RelationTypeDefinition) -&gt; None:\n        \"\"\"Creates a new relation type in the database.\n\n        Relation types define the schema for relationships between objects,\n        including the source and target object types and any properties of\n        the relation itself.\n\n        Args:\n            relation_type_def (RelationTypeDefinition): The definition of the\n                relation type to create.\n\n        Raises:\n            GrizabellaException: If the relation type already exists or if\n                there is an error during creation.\n            NotConnectedError: If the client is not connected to the database.\n\n        \"\"\"\n        self._db_manager.add_relation_type_definition(relation_type_def)\n\n    def get_relation_type(self, type_name: str) -&gt; Optional[RelationTypeDefinition]:\n        \"\"\"Retrieves the definition of a relation type.\n\n        Args:\n            type_name (str): The name of the relation type to retrieve.\n\n        Returns:\n            Optional[RelationTypeDefinition]: The definition of the relation\n            type if found, otherwise None.\n\n        Raises:\n            NotConnectedError: If the client is not connected to the database.\n\n        \"\"\"\n        return self._db_manager.get_relation_type_definition(type_name)\n\n    def delete_relation_type(self, type_name: str) -&gt; None:\n        \"\"\"Deletes a relation type from the database.\n\n        Warning: This operation may also delete all associated relation instances,\n        depending on the underlying database implementation.\n\n        Args:\n            type_name (str): The name of the relation type to delete.\n\n        Raises:\n            GrizabellaException: If the relation type does not exist or if\n                there is an error during deletion.\n            NotConnectedError: If the client is not connected to the database.\n\n        \"\"\"\n        self._db_manager.remove_relation_type_definition(type_name)\n\n    def list_relation_types(self) -&gt; list[RelationTypeDefinition]:\n        \"\"\"Lists all defined relation types in the database.\n\n        Returns:\n            List[RelationTypeDefinition]: A list of all relation type definitions.\n\n        Raises:\n            NotConnectedError: If the client is not connected to the database.\n\n        \"\"\"\n        if not self._is_connected:\n            self._db_manager.connect()  # Ensure connection\n        return self._db_manager.list_relation_type_definitions()\n\n    # --- Data Management (Objects) ---\n    def upsert_object(self, obj: ObjectInstance) -&gt; ObjectInstance:\n        \"\"\"Creates a new object or updates an existing one.\n\n        If an object with the same ID already exists, it will be updated\n        with the properties from the provided `ObjectInstance`. Otherwise, a\n        new object will be created.\n\n        Args:\n            obj (ObjectInstance): The object instance to create or update.\n                It must include the object type name and its properties.\n                The `id` field can be provided for updates or will be\n                generated for new objects if not supplied.\n\n        Returns:\n            ObjectInstance: The created or updated object instance, potentially\n            with a newly assigned ID or updated timestamps.\n\n        Raises:\n            GrizabellaException: If the object type does not exist or if there\n                is an error during the upsert operation.\n            NotConnectedError: If the client is not connected to the database.\n\n        \"\"\"\n        return self._db_manager.upsert_object_instance(obj)\n\n    def get_object_by_id(\n        self, object_id: str, type_name: str,\n    ) -&gt; Optional[ObjectInstance]:\n        \"\"\"Retrieves an object by its ID and type.\n\n        Args:\n            object_id (str): The unique identifier of the object.\n            type_name (str): The name of the object type.\n\n        Returns:\n            Optional[ObjectInstance]: The object instance if found,\n            otherwise None.\n\n        Raises:\n            GrizabellaException: If the object type does not exist or if there\n                is an error during retrieval.\n            NotConnectedError: If the client is not connected to the database.\n\n        \"\"\"\n        return self._db_manager.get_object_instance(\n            object_type_name=type_name, instance_id=object_id,\n        )\n\n    def delete_object(self, object_id: str, type_name: str) -&gt; bool:\n        \"\"\"Deletes an object by its ID and type.\n\n        Args:\n            object_id (str): The unique identifier of the object to delete.\n            type_name (str): The name of the object type.\n\n        Returns:\n            bool: True if the object was successfully deleted, False otherwise\n            (e.g., if the object was not found).\n\n        Raises:\n            GrizabellaException: If the object type does not exist or if there\n                is an error during deletion.\n            NotConnectedError: If the client is not connected to the database.\n\n        \"\"\"\n        return self._db_manager.delete_object_instance(\n            object_type_name=type_name, instance_id=object_id,\n        )\n\n    def find_objects(\n        self,\n        type_name: str,\n        filter_criteria: Optional[dict[str, Any]] = None,\n        limit: Optional[int] = None,\n    ) -&gt; list[ObjectInstance]:\n        \"\"\"Finds objects of a given type, optionally matching filter criteria.\n\n        Args:\n            type_name (str): The name of the object type to search for.\n            filter_criteria (Optional[Dict[str, Any]]): A dictionary where\n                keys are property names and values are the values to filter by.\n                Only objects matching all criteria will be returned.\n                Defaults to None (no filtering).\n            limit (Optional[int]): The maximum number of objects to return.\n                Defaults to None (no limit).\n\n        Returns:\n            List[ObjectInstance]: A list of object instances matching the\n            criteria.\n\n        Raises:\n            GrizabellaException: If the object type does not exist or if there\n                is an error during the search.\n            NotConnectedError: If the client is not connected to the database.\n\n        \"\"\"\n        return self._db_manager.query_object_instances(\n            object_type_name=type_name,\n            conditions=filter_criteria or {},\n            limit=limit,\n        )\n\n    # --- Data Management (Relations) ---\n    def add_relation(self, relation: RelationInstance) -&gt; RelationInstance:\n        \"\"\"Adds a new relation instance or updates an existing one (upsert).\n\n        If the provided `RelationInstance` object includes an `id` that matches\n        an existing relation, it will be updated. Otherwise, a new relation\n        instance will be created. The `upsert_date` metadata field is\n        automatically updated.\n\n        Args:\n            relation (RelationInstance): The relation instance to add or update.\n                It must specify the relation type name, source object ID,\n                target object ID, and any properties of the relation.\n                The `id` field can be provided for updates.\n\n        Returns:\n            RelationInstance: The created or updated relation instance,\n            potentially with a newly assigned ID or updated timestamps.\n\n        Raises:\n            GrizabellaException: If the relation type or involved objects do\n                not exist, or if there is an error during the upsert operation.\n            NotConnectedError: If the client is not connected to the database.\n\n        \"\"\"\n        return self._db_manager.add_relation_instance(relation)\n\n    def get_relation(\n        self, from_object_id: str, to_object_id: str, relation_type_name: str,\n    ) -&gt; list[RelationInstance]:\n        \"\"\"Retrieves relation instances between two objects of a specific type.\n\n        Note:\n            This method's current implementation in the client API differs\n            from the underlying `GrizabellaDBManager` which expects a\n            `relation_id`. This method currently raises `NotImplementedError`\n            and requires rework to correctly map to the DBManager's capabilities\n            or a change in the client API signature.\n\n        Args:\n            from_object_id (str): The ID of the source object of the relation.\n            to_object_id (str): The ID of the target object of the relation.\n            relation_type_name (str): The name of the relation type.\n\n        Returns:\n            List[RelationInstance]: A list of relation instances matching the criteria.\n            An empty list is returned if no matching relations are found.\n\n        Raises:\n            GrizabellaException: If there is an error during retrieval.\n            NotConnectedError: If the client is not connected to the database.\n            ValueError: If `from_object_id` or `to_object_id` are not valid UUID strings.\n\n        \"\"\"\n        if not self._is_connected:\n            self._db_manager.connect() # Ensure connection\n\n        try:\n            source_uuid = uuid.UUID(from_object_id)\n            target_uuid = uuid.UUID(to_object_id)\n        except ValueError as e:\n            msg = (\n                f\"Invalid UUID string for from_object_id ('{from_object_id}') or \"\n                f\"to_object_id ('{to_object_id}').\"\n            )\n            raise ValueError(\n                msg,\n            ) from e\n\n        return self._db_manager.find_relation_instances(\n            relation_type_name=relation_type_name,\n            source_object_id=source_uuid,\n            target_object_id=target_uuid,\n        )\n\n    def delete_relation(\n        self, relation_type_name: str, relation_id: str,\n    ) -&gt; bool:\n        \"\"\"Deletes a specific relation instance by its type and unique ID.\n\n        Args:\n            relation_type_name (str): The name of the relation type.\n            relation_id (str): The unique identifier of the relation instance to delete.\n\n        Returns:\n            bool: True if the relation was successfully deleted, False otherwise\n            (e.g., if the relation was not found).\n\n        Raises:\n            GrizabellaException: If there is an error during deletion.\n            NotConnectedError: If the client is not connected to the database.\n            ValueError: If `relation_id` is not a valid UUID string.\n\n        \"\"\"\n        if not self._is_connected:\n            self._db_manager.connect() # Ensure connection\n\n        try:\n            rel_uuid = uuid.UUID(relation_id)\n        except ValueError as e:\n            msg = f\"Invalid UUID string for relation_id: '{relation_id}'.\"\n            raise ValueError(\n                msg,\n            ) from e\n\n        return self._db_manager.delete_relation_instance(\n            relation_type_name=relation_type_name,\n            relation_id=rel_uuid,\n        )\n\n    def query_relations(\n        self,\n        relation_type_name: Optional[str] = None,\n        source_object_instance_id: Optional[str] = None,\n        target_object_instance_id: Optional[str] = None,\n        properties_query: Optional[dict[str, Any]] = None, # Matches 'query' in db_manager\n        limit: Optional[int] = None,\n    ) -&gt; list[RelationInstance]:\n        \"\"\"Queries relation instances based on various criteria.\n\n        Args:\n            relation_type_name (Optional[str]): Filter by relation type name.\n            source_object_instance_id (Optional[str]): Filter by source object ID (UUID string).\n            target_object_instance_id (Optional[str]): Filter by target object ID (UUID string).\n            properties_query (Optional[dict[str, Any]]): Filter by relation properties.\n            limit (Optional[int]): Maximum number of results to return.\n\n        Returns:\n            List[RelationInstance]: A list of matching relation instances.\n\n        Raises:\n            NotConnectedError: If the client is not connected to the database.\n            ValueError: If provided UUID strings are invalid.\n            GrizabellaException: For other underlying database or processing errors.\n\n        \"\"\"\n        if not self._is_connected:\n            self._db_manager.connect()  # Ensure connection\n\n        source_uuid: Optional[uuid.UUID] = None\n        if source_object_instance_id:\n            try:\n                source_uuid = uuid.UUID(source_object_instance_id)\n            except ValueError as e:\n                raise ValueError(f\"Invalid UUID string for source_object_instance_id: '{source_object_instance_id}'.\") from e\n\n        target_uuid: Optional[uuid.UUID] = None\n        if target_object_instance_id:\n            try:\n                target_uuid = uuid.UUID(target_object_instance_id)\n            except ValueError as e:\n                raise ValueError(f\"Invalid UUID string for target_object_instance_id: '{target_object_instance_id}'.\") from e\n\n        return self._db_manager.find_relation_instances(\n            relation_type_name=relation_type_name,\n            source_object_id=source_uuid, # Pass UUID object\n            target_object_id=target_uuid, # Pass UUID object\n            query=properties_query,\n            limit=limit,\n        )\n\n    def get_outgoing_relations(\n        self, object_id: str, type_name: str, relation_type_name: Optional[str] = None, # pylint: disable=unused-argument\n    ) -&gt; list[RelationInstance]:\n        \"\"\"Retrieves all outgoing relations from a given object.\n\n        Args:\n            object_id (str): The ID of the source object.\n            type_name (str): The type name of the source object. (Note: This\n                parameter is not directly used by the underlying DBManager's\n                `find_relation_instances` for this specific query but is kept\n                for API consistency or future use).\n            relation_type_name (Optional[str]): If provided, filters relations\n                by this specific relation type name. Defaults to None (no filter).\n\n        Returns:\n            List[RelationInstance]: A list of outgoing relation instances.\n\n        Raises:\n            GrizabellaException: If there is an error during retrieval.\n            NotConnectedError: If the client is not connected to the database.\n            ValueError: If `object_id` is not a valid UUID string.\n\n        \"\"\"\n        if not self._is_connected:\n            self._db_manager.connect()  # Ensure connection\n        try:\n            source_uuid = uuid.UUID(object_id)\n        except ValueError as e:\n            # It's generally better to let exceptions propagate or handle them more specifically.\n            # For now, re-raising to make it clear to the caller.\n            msg = f\"Invalid UUID string for source_object_id: {object_id}\"\n            raise ValueError(\n                msg,\n            ) from e\n\n        return self._db_manager.find_relation_instances(\n            relation_type_name=relation_type_name, source_object_id=source_uuid,\n        )\n\n    def get_incoming_relations(\n        self, object_id: str, type_name: str, relation_type_name: Optional[str] = None, # pylint: disable=unused-argument\n    ) -&gt; list[RelationInstance]:\n        \"\"\"Retrieves all incoming relations to a given object.\n\n        Args:\n            object_id (str): The ID of the target object.\n            type_name (str): The type name of the target object. (Note: This\n                parameter is not directly used by the underlying DBManager's\n                `find_relation_instances` for this specific query but is kept\n                for API consistency or future use).\n            relation_type_name (Optional[str]): If provided, filters relations\n                by this specific relation type name. Defaults to None (no filter).\n\n        Returns:\n            List[RelationInstance]: A list of incoming relation instances.\n\n        Raises:\n            GrizabellaException: If there is an error during retrieval.\n            NotConnectedError: If the client is not connected to the database.\n            ValueError: If `object_id` is not a valid UUID string.\n\n        \"\"\"\n        if not self._is_connected:\n            self._db_manager.connect()  # Ensure connection\n        try:\n            target_uuid = uuid.UUID(object_id)\n        except ValueError as e:\n            msg = f\"Invalid UUID string for target_object_id: {object_id}\"\n            raise ValueError(\n                msg,\n            ) from e\n\n        return self._db_manager.find_relation_instances(\n            relation_type_name=relation_type_name, target_object_id=target_uuid,\n        )\n\n    # --- Embedding Definition Management ---\n    def create_embedding_definition(\n        self, embedding_def: EmbeddingDefinition,\n    ) -&gt; EmbeddingDefinition:\n        \"\"\"Creates a new embedding definition.\n\n        Embedding definitions specify how embeddings should be generated and\n        stored for objects of a particular type or for specific properties.\n\n        Args:\n            embedding_def (EmbeddingDefinition): The definition of the\n                embedding to create, including its name, model details,\n                and associated object type or properties.\n\n        Returns:\n            EmbeddingDefinition: The created embedding definition.\n\n        Raises:\n            GrizabellaException: If an embedding definition with the same name\n                already exists or if there is an error during creation.\n            NotConnectedError: If the client is not connected to the database.\n\n        \"\"\"\n        if not self._is_connected:\n            self._db_manager.connect()\n        self._db_manager.add_embedding_definition(embedding_def, persist=True)\n        return embedding_def\n\n    def get_embedding_definition(self, name: str) -&gt; Optional[EmbeddingDefinition]:\n        \"\"\"Retrieves an embedding definition by its name.\n\n        Args:\n            name (str): The name of the embedding definition to retrieve.\n\n        Returns:\n            Optional[EmbeddingDefinition]: The embedding definition if found,\n            otherwise None.\n\n        Raises:\n            NotConnectedError: If the client is not connected to the database.\n\n        \"\"\"\n        if not self._is_connected:\n            self._db_manager.connect()\n        return self._db_manager.get_embedding_definition(name)\n\n    def list_embedding_definitions(self) -&gt; list[EmbeddingDefinition]:\n        \"\"\"Lists all embedding definitions in the database.\n\n        Returns:\n            List[EmbeddingDefinition]: A list of all embedding definitions.\n\n        Raises:\n            NotConnectedError: If the client is not connected to the database.\n\n        \"\"\"\n        if not self._is_connected:\n            self._db_manager.connect()\n        return self._db_manager.list_embedding_definitions()\n\n    def delete_embedding_definition(self, name: str) -&gt; bool:\n        \"\"\"Deletes an embedding definition.\n\n        Warning: This may also delete associated embedding vectors from the\n        vector store, depending on the implementation.\n\n        Args:\n            name (str): The name of the embedding definition to delete.\n\n        Returns:\n            bool: True if the definition was successfully deleted, False\n            otherwise (e.g., if not found).\n\n        Raises:\n            GrizabellaException: If there is an error during deletion.\n            NotConnectedError: If the client is not connected to the database.\n\n        \"\"\"\n        if not self._is_connected:\n            self._db_manager.connect()\n        return self._db_manager.remove_embedding_definition(name, persist=True)\n\n    # --- Querying (Example: Embedding Search) ---\n    def search_similar_objects(\n        self,\n        object_id: str,\n        type_name: str,\n        n_results: int = 5,\n        search_properties: Optional[list[str]] = None,\n    ) -&gt; list[tuple[ObjectInstance, float]]:\n        \"\"\"Searches for objects similar to a given object using its embeddings.\n\n        This method finds objects of the same type as the source object that\n        are semantically similar, based on a specified or inferred embedding definition.\n\n        Args:\n            object_id (str): The ID of the source object to find similar items for.\n            type_name (str): The type name of the source object.\n            n_results (int): The maximum number of similar results to return.\n                Defaults to 5.\n            search_properties (Optional[List[str]]): If provided, the first element\n                is used as the specific `embedding_definition_name` to use for both\n                the source object's vector retrieval and the target search.\n                If None or empty, the first available `EmbeddingDefinition` for the\n                `type_name` will be used.\n\n        Returns:\n            List[Tuple[ObjectInstance, float]]: A list of tuples, where each\n            tuple contains a similar `ObjectInstance` and its similarity score\n            (typically distance, where lower is more similar).\n\n        Raises:\n            NotConnectedError: If the client is not connected to the database.\n            ValueError: If `object_id` is not a valid UUID string.\n            SchemaError: If a suitable `EmbeddingDefinition` cannot be found.\n            EmbeddingError: If an embedding for the source object cannot be found.\n            GrizabellaException: For other underlying database or processing errors.\n\n        \"\"\"\n        if not self._is_connected:\n            self._db_manager.connect()\n\n        try:\n            source_uuid = uuid.UUID(object_id)\n        except ValueError as e:\n            msg = f\"Invalid UUID string for object_id: '{object_id}'.\"\n            raise ValueError(msg) from e\n\n        embedding_definition_name: Optional[str] = None\n        if search_properties and search_properties[0]:\n            embedding_definition_name = search_properties[0]\n            # Validate this ED exists and is for the correct object type\n            ed = self._db_manager.get_embedding_definition(embedding_definition_name)\n            if not ed:\n                msg = f\"Specified EmbeddingDefinition '{embedding_definition_name}' not found.\"\n                raise SchemaError(\n                    msg,\n                )\n            if ed.object_type_name != type_name:\n                msg = (\n                    f\"Specified EmbeddingDefinition '{embedding_definition_name}' is for object type \"\n                    f\"'{ed.object_type_name}', but expected type '{type_name}' for object '{object_id}'.\"\n                )\n                raise SchemaError(\n                    msg,\n                )\n        else:\n            # Find the first available EmbeddingDefinition for the type_name\n            all_eds = self._db_manager.list_embedding_definitions()\n            for ed in all_eds:\n                if ed.object_type_name == type_name:\n                    embedding_definition_name = ed.name\n                    break\n            if not embedding_definition_name:\n                msg = (\n                    f\"No EmbeddingDefinition found for object type '{type_name}'. \"\n                    \"Cannot perform similarity search.\"\n                )\n                raise SchemaError(\n                    msg,\n                )\n\n        return self._db_manager.find_objects_similar_to_instance(\n            source_object_id=source_uuid,\n            source_object_type_name=type_name,\n            embedding_definition_name=embedding_definition_name,\n            n_results=n_results,\n        )\n\n    def find_similar(\n        self,\n        embedding_name: str,\n        query_text: str,\n        limit: int = 5,\n        filter_condition: Optional[str] = None,\n    ) -&gt; list[ObjectInstance]: # Changed return type to list[ObjectInstance] for simplicity in test\n        \"\"\"Finds objects semantically similar to a given query text.\n\n        Args:\n            embedding_name (str): The name of the EmbeddingDefinition to use.\n            query_text (str): The text to find similar objects for.\n            limit (int): The maximum number of similar results to return. Defaults to 5.\n            filter_condition (Optional[str]): An SQL-like WHERE clause to pre-filter results.\n\n        Returns:\n            List[ObjectInstance]: A list of ObjectInstances that are semantically\n            similar to the query_text, ordered by similarity.\n\n        Raises:\n            NotConnectedError: If the client is not connected to the database.\n            SchemaError: If the specified EmbeddingDefinition is not found or is invalid.\n            EmbeddingError: If an error occurs during embedding generation or search.\n            GrizabellaException: For other underlying database or processing errors.\n\n        \"\"\"\n        if not self._is_connected:\n            self._db_manager.connect()\n\n        ed = self._db_manager.get_embedding_definition(embedding_name)\n        if not ed:\n            msg = f\"EmbeddingDefinition '{embedding_name}' not found.\"\n            raise SchemaError(msg)\n\n        # Call the db_manager's method that can handle query_text\n        # This method in _InstanceManager returns raw results: list[dict[str, Any]]\n        # where dicts contain 'object_instance_id' and '_distance'\n        raw_results = self._db_manager.find_similar_objects_by_embedding(\n            embedding_definition_name=embedding_name,\n            query_text=query_text,\n            limit=limit,\n            retrieve_full_objects=False, # We need IDs and scores to process further\n            filter_condition=filter_condition,\n        )\n\n        if not raw_results:\n            return []\n\n        # We need to convert raw_results (list of dicts with id and score)\n        # into a list of ObjectInstance, similar to how find_objects_similar_to_instance does.\n        # The _process_raw_similarity_results method in DBManager is suitable.\n        # It expects a source_object_id for filtering, which is not applicable here.\n        # We'll adapt its logic or call it carefully.\n\n        # Let's get the target object type from the embedding definition\n        target_object_type_name = ed.object_type_name\n\n        # Re-implementing parts of _process_raw_similarity_results logic here\n        # as it's not directly callable with a query_text scenario (no source_object_id)\n\n        final_results_with_scores: list[tuple[ObjectInstance, float]] = []\n        result_ids_map: dict[uuid.UUID, float] = {}\n\n        for res in raw_results:\n            try:\n                obj_id_str = res.get(\"object_instance_id\")\n                if not obj_id_str:\n                    continue\n                obj_id = uuid.UUID(obj_id_str)\n                score = float(res.get(\"_distance\", 0.0)) # LanceDB uses _distance\n                result_ids_map[obj_id] = score\n            except (ValueError, KeyError, TypeError) as e:\n                # self._db_manager._logger.warning(...) # Can't access logger directly\n                print(f\"Warning: Skipping result due to parsing error: {res}, error: {e}\") # Basic print for now\n                continue\n\n        if not result_ids_map:\n            return []\n\n        sorted_similar_items = sorted(result_ids_map.items(), key=lambda item: item[1])[:limit]\n        result_ids_to_fetch = [item[0] for item in sorted_similar_items]\n\n        if result_ids_to_fetch:\n            # Convert UUIDs to strings for get_objects_by_ids if it expects strings\n            # However, db_manager.get_objects_by_ids takes list[uuid.UUID]\n            fetched_objects = self._db_manager.get_objects_by_ids(\n                target_object_type_name, result_ids_to_fetch,\n            )\n            fetched_objects_map = {obj.id: obj for obj in fetched_objects}\n\n            for obj_id_val, _ in sorted_similar_items: # score_val not used in final list of ObjectInstance\n                if obj_id_val in fetched_objects_map:\n                    final_results_with_scores.append(\n                        (fetched_objects_map[obj_id_val], _), # Keep score for potential future use\n                    )\n\n        # Return only the ObjectInstances, ordered by similarity (which sorted_similar_items already did)\n        return [obj_inst for obj_inst, score in final_results_with_scores]\n\n    # --- Complex Querying ---\n    def execute_complex_query(self, query: ComplexQuery) -&gt; QueryResult:\n        \"\"\"Executes a complex query spanning multiple database layers.\n\n        Complex queries allow for sophisticated search patterns, including\n        graph traversals, relational filters, and embedding-based searches,\n        combined into a single query operation.\n\n        Args:\n            query (ComplexQuery): A ``ComplexQuery`` object defining the\n                components of the search, such as graph traversals,\n                relational filters, and embedding searches.\n\n        Returns:\n            QueryResult: A ``QueryResult`` object containing a list of matching\n            ``ObjectInstance``s and a list of any errors encountered during\n            query processing.\n\n        Raises:\n            NotConnectedError: If the client is not connected to the database.\n            GrizabellaException: If there is an error during query planning\n                or execution.\n\n        \"\"\"\n        if not self._is_connected:\n            raise DatabaseError(\"Database not connected. Call connect() before executing queries.\")\n\n        if hasattr(self._db_manager, \"process_complex_query\"):\n            return self._db_manager.process_complex_query(query)\n        # This indicates a missing implementation in the DBManager,\n        # which is a development-time issue.\n        # Raising NotImplementedError is more appropriate here.\n        msg = \"GrizabellaDBManager.process_complex_query not yet implemented.\"\n        raise NotImplementedError(\n            msg,\n        )\n</code></pre>"},{"location":"api/client/#grizabella.api.client.Grizabella.db_name_or_path","title":"<code>db_name_or_path: Union[str, Path]</code>  <code>property</code>","text":"<p>Returns the database name or path this client was initialized with.</p>"},{"location":"api/client/#grizabella.api.client.Grizabella.__enter__","title":"<code>__enter__()</code>","text":"<p>Context manager entry point. Connects to the database.</p> <p>Returns:</p> Name Type Description <code>Grizabella</code> <code>Grizabella</code> <p>The Grizabella API client instance.</p> Source code in <code>grizabella/api/client.py</code> <pre><code>def __enter__(self) -&gt; \"Grizabella\":\n    \"\"\"Context manager entry point. Connects to the database.\n\n    Returns:\n        Grizabella: The Grizabella API client instance.\n\n    \"\"\"\n    self.connect()\n    return self\n</code></pre>"},{"location":"api/client/#grizabella.api.client.Grizabella.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Context manager exit point. Closes the database connection.</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>Optional[type[BaseException]]</code> <p>The type of the exception, if any.</p> required <code>exc_val</code> <code>Optional[BaseException]</code> <p>The exception instance, if any.</p> required <code>exc_tb</code> <code>Optional[Any]</code> <p>The traceback object, if any.</p> required Source code in <code>grizabella/api/client.py</code> <pre><code>def __exit__(\n    self,\n    exc_type: Optional[type[BaseException]],\n    exc_val: Optional[BaseException],\n    exc_tb: Optional[Any],\n) -&gt; None:\n    \"\"\"Context manager exit point. Closes the database connection.\n\n    Args:\n        exc_type: The type of the exception, if any.\n        exc_val: The exception instance, if any.\n        exc_tb: The traceback object, if any.\n\n    \"\"\"\n    self.close()\n</code></pre>"},{"location":"api/client/#grizabella.api.client.Grizabella.__init__","title":"<code>__init__(db_name_or_path='default', create_if_not_exists=True)</code>","text":"<p>Initializes the Grizabella API client.</p> <p>Sets up the connection to the specified Grizabella database. If the database does not exist and <code>create_if_not_exists</code> is True, it will be created.</p> <p>Parameters:</p> Name Type Description Default <code>db_name_or_path</code> <code>Union[str, Path]</code> <p>The name of the database or the file system path to the database directory. Defaults to \"default\".</p> <code>'default'</code> <code>create_if_not_exists</code> <code>bool</code> <p>If True, the database will be created if it does not already exist. Defaults to True.</p> <code>True</code> Source code in <code>grizabella/api/client.py</code> <pre><code>def __init__(\n    self,\n    db_name_or_path: Union[str, Path] = \"default\",\n    create_if_not_exists: bool = True,\n) -&gt; None:\n    \"\"\"Initializes the Grizabella API client.\n\n    Sets up the connection to the specified Grizabella database. If the\n    database does not exist and `create_if_not_exists` is True, it will\n    be created.\n\n    Args:\n        db_name_or_path (Union[str, Path]): The name of the database or\n            the file system path to the database directory.\n            Defaults to \"default\".\n        create_if_not_exists (bool): If True, the database will be\n            created if it does not already exist. Defaults to True.\n\n    \"\"\"\n    self._logger = logging.getLogger(__name__) # Initialize logger\n    self._initial_db_name_or_path = db_name_or_path # Store the initial path/name\n\n    # Use factory for DBManager to enable singleton pattern and proper lifecycle management\n    self._db_manager_factory = get_db_manager_factory()\n\n    # Check if GrizabellaDBManager has been mocked (for testing)\n    import grizabella.api.client as client_module\n    if hasattr(client_module, 'GrizabellaDBManager') and hasattr(client_module.GrizabellaDBManager, 'return_value'):\n        # If GrizabellaDBManager is a mock, call the constructor to ensure it's tracked by tests\n        # but then use the mock instance for method calls\n        manager_constructor_args = {\n            'db_name_or_path': db_name_or_path,\n            'create_if_not_exists': create_if_not_exists,\n        }\n        # Call the constructor to register the call for test verification\n        client_module.GrizabellaDBManager(**manager_constructor_args)\n        # Use the mock instance for all subsequent operations\n        self._db_manager = client_module.GrizabellaDBManager.return_value\n    else:\n        self._db_manager = self._db_manager_factory.get_manager(\n            db_name_or_path=db_name_or_path,\n            create_if_not_exists=create_if_not_exists,\n        )\n\n    self._is_connected = False\n\n    self._logger.info(f\"Grizabella client initialized for database: {db_name_or_path} using factory pattern\")\n</code></pre>"},{"location":"api/client/#grizabella.api.client.Grizabella.add_relation","title":"<code>add_relation(relation)</code>","text":"<p>Adds a new relation instance or updates an existing one (upsert).</p> <p>If the provided <code>RelationInstance</code> object includes an <code>id</code> that matches an existing relation, it will be updated. Otherwise, a new relation instance will be created. The <code>upsert_date</code> metadata field is automatically updated.</p> <p>Parameters:</p> Name Type Description Default <code>relation</code> <code>RelationInstance</code> <p>The relation instance to add or update. It must specify the relation type name, source object ID, target object ID, and any properties of the relation. The <code>id</code> field can be provided for updates.</p> required <p>Returns:</p> Name Type Description <code>RelationInstance</code> <code>RelationInstance</code> <p>The created or updated relation instance,</p> <code>RelationInstance</code> <p>potentially with a newly assigned ID or updated timestamps.</p> <p>Raises:</p> Type Description <code>GrizabellaException</code> <p>If the relation type or involved objects do not exist, or if there is an error during the upsert operation.</p> <code>NotConnectedError</code> <p>If the client is not connected to the database.</p> Source code in <code>grizabella/api/client.py</code> <pre><code>def add_relation(self, relation: RelationInstance) -&gt; RelationInstance:\n    \"\"\"Adds a new relation instance or updates an existing one (upsert).\n\n    If the provided `RelationInstance` object includes an `id` that matches\n    an existing relation, it will be updated. Otherwise, a new relation\n    instance will be created. The `upsert_date` metadata field is\n    automatically updated.\n\n    Args:\n        relation (RelationInstance): The relation instance to add or update.\n            It must specify the relation type name, source object ID,\n            target object ID, and any properties of the relation.\n            The `id` field can be provided for updates.\n\n    Returns:\n        RelationInstance: The created or updated relation instance,\n        potentially with a newly assigned ID or updated timestamps.\n\n    Raises:\n        GrizabellaException: If the relation type or involved objects do\n            not exist, or if there is an error during the upsert operation.\n        NotConnectedError: If the client is not connected to the database.\n\n    \"\"\"\n    return self._db_manager.add_relation_instance(relation)\n</code></pre>"},{"location":"api/client/#grizabella.api.client.Grizabella.close","title":"<code>close()</code>","text":"<p>Closes the connection to the underlying Grizabella database.</p> <p>Releases any resources held by the database connection. It's important to close the connection when it's no longer needed, especially if not using the client as a context manager.</p> <p>Raises:</p> Type Description <code>GrizabellaException</code> <p>If there is an error closing the database connection.</p> Source code in <code>grizabella/api/client.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Closes the connection to the underlying Grizabella database.\n\n    Releases any resources held by the database connection. It's important\n    to close the connection when it's no longer needed, especially if not\n    using the client as a context manager.\n\n    Raises:\n        GrizabellaException: If there is an error closing the database connection.\n\n    \"\"\"\n    self._logger.info(f\"Grizabella client close() called for db: {self.db_name_or_path}. Connected: {self._is_connected}\")\n    if self._is_connected:\n        try:\n            self._db_manager.close() # This should call _ConnectionHelper.close_all_adapters()\n            self._logger.info(f\"Grizabella client: self._db_manager.close() completed for {self.db_name_or_path}.\")\n        except Exception as e:\n            self._logger.error(f\"Grizabella client: Error during self._db_manager.close() for {self.db_name_or_path}: {e}\", exc_info=True)\n        finally:\n            self._is_connected = False\n            self._logger.info(f\"Grizabella client: _is_connected set to False for {self.db_name_or_path}.\")\n    else:\n        self._logger.info(f\"Grizabella client: Already not connected for {self.db_name_or_path}, no action taken in close().\")\n</code></pre>"},{"location":"api/client/#grizabella.api.client.Grizabella.connect","title":"<code>connect()</code>","text":"<p>Connects to the underlying Grizabella database.</p> <p>Establishes a connection to the database if not already connected. This method is typically called automatically when using the client as a context manager or before performing database operations if the connection was previously closed.</p> <p>Raises:</p> Type Description <code>GrizabellaException</code> <p>If there is an error connecting to the database.</p> Source code in <code>grizabella/api/client.py</code> <pre><code>def connect(self) -&gt; None:\n    \"\"\"Connects to the underlying Grizabella database.\n\n    Establishes a connection to the database if not already connected.\n    This method is typically called automatically when using the client\n    as a context manager or before performing database operations if\n    the connection was previously closed.\n\n    Raises:\n        GrizabellaException: If there is an error connecting to the database.\n\n    \"\"\"\n    if not self._is_connected:\n        self._db_manager.connect()\n        self._is_connected = True\n</code></pre>"},{"location":"api/client/#grizabella.api.client.Grizabella.create_embedding_definition","title":"<code>create_embedding_definition(embedding_def)</code>","text":"<p>Creates a new embedding definition.</p> <p>Embedding definitions specify how embeddings should be generated and stored for objects of a particular type or for specific properties.</p> <p>Parameters:</p> Name Type Description Default <code>embedding_def</code> <code>EmbeddingDefinition</code> <p>The definition of the embedding to create, including its name, model details, and associated object type or properties.</p> required <p>Returns:</p> Name Type Description <code>EmbeddingDefinition</code> <code>EmbeddingDefinition</code> <p>The created embedding definition.</p> <p>Raises:</p> Type Description <code>GrizabellaException</code> <p>If an embedding definition with the same name already exists or if there is an error during creation.</p> <code>NotConnectedError</code> <p>If the client is not connected to the database.</p> Source code in <code>grizabella/api/client.py</code> <pre><code>def create_embedding_definition(\n    self, embedding_def: EmbeddingDefinition,\n) -&gt; EmbeddingDefinition:\n    \"\"\"Creates a new embedding definition.\n\n    Embedding definitions specify how embeddings should be generated and\n    stored for objects of a particular type or for specific properties.\n\n    Args:\n        embedding_def (EmbeddingDefinition): The definition of the\n            embedding to create, including its name, model details,\n            and associated object type or properties.\n\n    Returns:\n        EmbeddingDefinition: The created embedding definition.\n\n    Raises:\n        GrizabellaException: If an embedding definition with the same name\n            already exists or if there is an error during creation.\n        NotConnectedError: If the client is not connected to the database.\n\n    \"\"\"\n    if not self._is_connected:\n        self._db_manager.connect()\n    self._db_manager.add_embedding_definition(embedding_def, persist=True)\n    return embedding_def\n</code></pre>"},{"location":"api/client/#grizabella.api.client.Grizabella.create_object_type","title":"<code>create_object_type(object_type_def)</code>","text":"<p>Creates a new object type in the database.</p> <p>Object types define the schema for a category of objects, similar to tables in a relational database or node labels in a graph database.</p> <p>Parameters:</p> Name Type Description Default <code>object_type_def</code> <code>ObjectTypeDefinition</code> <p>The definition of the object type to create, including its name and properties.</p> required <p>Raises:</p> Type Description <code>GrizabellaException</code> <p>If the object type already exists or if there is an error during creation.</p> <code>NotConnectedError</code> <p>If the client is not connected to the database.</p> Source code in <code>grizabella/api/client.py</code> <pre><code>def create_object_type(self, object_type_def: ObjectTypeDefinition) -&gt; None:\n    \"\"\"Creates a new object type in the database.\n\n    Object types define the schema for a category of objects, similar to\n    tables in a relational database or node labels in a graph database.\n\n    Args:\n        object_type_def (ObjectTypeDefinition): The definition of the\n            object type to create, including its name and properties.\n\n    Raises:\n        GrizabellaException: If the object type already exists or if there\n            is an error during creation.\n        NotConnectedError: If the client is not connected to the database.\n\n    \"\"\"\n    self._db_manager.add_object_type_definition(object_type_def)\n</code></pre>"},{"location":"api/client/#grizabella.api.client.Grizabella.create_relation_type","title":"<code>create_relation_type(relation_type_def)</code>","text":"<p>Creates a new relation type in the database.</p> <p>Relation types define the schema for relationships between objects, including the source and target object types and any properties of the relation itself.</p> <p>Parameters:</p> Name Type Description Default <code>relation_type_def</code> <code>RelationTypeDefinition</code> <p>The definition of the relation type to create.</p> required <p>Raises:</p> Type Description <code>GrizabellaException</code> <p>If the relation type already exists or if there is an error during creation.</p> <code>NotConnectedError</code> <p>If the client is not connected to the database.</p> Source code in <code>grizabella/api/client.py</code> <pre><code>def create_relation_type(self, relation_type_def: RelationTypeDefinition) -&gt; None:\n    \"\"\"Creates a new relation type in the database.\n\n    Relation types define the schema for relationships between objects,\n    including the source and target object types and any properties of\n    the relation itself.\n\n    Args:\n        relation_type_def (RelationTypeDefinition): The definition of the\n            relation type to create.\n\n    Raises:\n        GrizabellaException: If the relation type already exists or if\n            there is an error during creation.\n        NotConnectedError: If the client is not connected to the database.\n\n    \"\"\"\n    self._db_manager.add_relation_type_definition(relation_type_def)\n</code></pre>"},{"location":"api/client/#grizabella.api.client.Grizabella.delete_embedding_definition","title":"<code>delete_embedding_definition(name)</code>","text":"<p>Deletes an embedding definition.</p> <p>Warning: This may also delete associated embedding vectors from the vector store, depending on the implementation.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the embedding definition to delete.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the definition was successfully deleted, False</p> <code>bool</code> <p>otherwise (e.g., if not found).</p> <p>Raises:</p> Type Description <code>GrizabellaException</code> <p>If there is an error during deletion.</p> <code>NotConnectedError</code> <p>If the client is not connected to the database.</p> Source code in <code>grizabella/api/client.py</code> <pre><code>def delete_embedding_definition(self, name: str) -&gt; bool:\n    \"\"\"Deletes an embedding definition.\n\n    Warning: This may also delete associated embedding vectors from the\n    vector store, depending on the implementation.\n\n    Args:\n        name (str): The name of the embedding definition to delete.\n\n    Returns:\n        bool: True if the definition was successfully deleted, False\n        otherwise (e.g., if not found).\n\n    Raises:\n        GrizabellaException: If there is an error during deletion.\n        NotConnectedError: If the client is not connected to the database.\n\n    \"\"\"\n    if not self._is_connected:\n        self._db_manager.connect()\n    return self._db_manager.remove_embedding_definition(name, persist=True)\n</code></pre>"},{"location":"api/client/#grizabella.api.client.Grizabella.delete_object","title":"<code>delete_object(object_id, type_name)</code>","text":"<p>Deletes an object by its ID and type.</p> <p>Parameters:</p> Name Type Description Default <code>object_id</code> <code>str</code> <p>The unique identifier of the object to delete.</p> required <code>type_name</code> <code>str</code> <p>The name of the object type.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the object was successfully deleted, False otherwise</p> <code>bool</code> <p>(e.g., if the object was not found).</p> <p>Raises:</p> Type Description <code>GrizabellaException</code> <p>If the object type does not exist or if there is an error during deletion.</p> <code>NotConnectedError</code> <p>If the client is not connected to the database.</p> Source code in <code>grizabella/api/client.py</code> <pre><code>def delete_object(self, object_id: str, type_name: str) -&gt; bool:\n    \"\"\"Deletes an object by its ID and type.\n\n    Args:\n        object_id (str): The unique identifier of the object to delete.\n        type_name (str): The name of the object type.\n\n    Returns:\n        bool: True if the object was successfully deleted, False otherwise\n        (e.g., if the object was not found).\n\n    Raises:\n        GrizabellaException: If the object type does not exist or if there\n            is an error during deletion.\n        NotConnectedError: If the client is not connected to the database.\n\n    \"\"\"\n    return self._db_manager.delete_object_instance(\n        object_type_name=type_name, instance_id=object_id,\n    )\n</code></pre>"},{"location":"api/client/#grizabella.api.client.Grizabella.delete_object_type","title":"<code>delete_object_type(type_name)</code>","text":"<p>Deletes an object type from the database.</p> <p>Warning: This operation may also delete all associated object instances and relations, depending on the underlying database implementation and cascade rules.</p> <p>Parameters:</p> Name Type Description Default <code>type_name</code> <code>str</code> <p>The name of the object type to delete.</p> required <p>Raises:</p> Type Description <code>GrizabellaException</code> <p>If the object type does not exist or if there is an error during deletion.</p> <code>NotConnectedError</code> <p>If the client is not connected to the database.</p> Source code in <code>grizabella/api/client.py</code> <pre><code>def delete_object_type(self, type_name: str) -&gt; None:\n    \"\"\"Deletes an object type from the database.\n\n    Warning: This operation may also delete all associated object instances\n    and relations, depending on the underlying database implementation and\n    cascade rules.\n\n    Args:\n        type_name (str): The name of the object type to delete.\n\n    Raises:\n        GrizabellaException: If the object type does not exist or if there\n            is an error during deletion.\n        NotConnectedError: If the client is not connected to the database.\n\n    \"\"\"\n    self._db_manager.remove_object_type_definition(type_name)\n</code></pre>"},{"location":"api/client/#grizabella.api.client.Grizabella.delete_relation","title":"<code>delete_relation(relation_type_name, relation_id)</code>","text":"<p>Deletes a specific relation instance by its type and unique ID.</p> <p>Parameters:</p> Name Type Description Default <code>relation_type_name</code> <code>str</code> <p>The name of the relation type.</p> required <code>relation_id</code> <code>str</code> <p>The unique identifier of the relation instance to delete.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the relation was successfully deleted, False otherwise</p> <code>bool</code> <p>(e.g., if the relation was not found).</p> <p>Raises:</p> Type Description <code>GrizabellaException</code> <p>If there is an error during deletion.</p> <code>NotConnectedError</code> <p>If the client is not connected to the database.</p> <code>ValueError</code> <p>If <code>relation_id</code> is not a valid UUID string.</p> Source code in <code>grizabella/api/client.py</code> <pre><code>def delete_relation(\n    self, relation_type_name: str, relation_id: str,\n) -&gt; bool:\n    \"\"\"Deletes a specific relation instance by its type and unique ID.\n\n    Args:\n        relation_type_name (str): The name of the relation type.\n        relation_id (str): The unique identifier of the relation instance to delete.\n\n    Returns:\n        bool: True if the relation was successfully deleted, False otherwise\n        (e.g., if the relation was not found).\n\n    Raises:\n        GrizabellaException: If there is an error during deletion.\n        NotConnectedError: If the client is not connected to the database.\n        ValueError: If `relation_id` is not a valid UUID string.\n\n    \"\"\"\n    if not self._is_connected:\n        self._db_manager.connect() # Ensure connection\n\n    try:\n        rel_uuid = uuid.UUID(relation_id)\n    except ValueError as e:\n        msg = f\"Invalid UUID string for relation_id: '{relation_id}'.\"\n        raise ValueError(\n            msg,\n        ) from e\n\n    return self._db_manager.delete_relation_instance(\n        relation_type_name=relation_type_name,\n        relation_id=rel_uuid,\n    )\n</code></pre>"},{"location":"api/client/#grizabella.api.client.Grizabella.delete_relation_type","title":"<code>delete_relation_type(type_name)</code>","text":"<p>Deletes a relation type from the database.</p> <p>Warning: This operation may also delete all associated relation instances, depending on the underlying database implementation.</p> <p>Parameters:</p> Name Type Description Default <code>type_name</code> <code>str</code> <p>The name of the relation type to delete.</p> required <p>Raises:</p> Type Description <code>GrizabellaException</code> <p>If the relation type does not exist or if there is an error during deletion.</p> <code>NotConnectedError</code> <p>If the client is not connected to the database.</p> Source code in <code>grizabella/api/client.py</code> <pre><code>def delete_relation_type(self, type_name: str) -&gt; None:\n    \"\"\"Deletes a relation type from the database.\n\n    Warning: This operation may also delete all associated relation instances,\n    depending on the underlying database implementation.\n\n    Args:\n        type_name (str): The name of the relation type to delete.\n\n    Raises:\n        GrizabellaException: If the relation type does not exist or if\n            there is an error during deletion.\n        NotConnectedError: If the client is not connected to the database.\n\n    \"\"\"\n    self._db_manager.remove_relation_type_definition(type_name)\n</code></pre>"},{"location":"api/client/#grizabella.api.client.Grizabella.execute_complex_query","title":"<code>execute_complex_query(query)</code>","text":"<p>Executes a complex query spanning multiple database layers.</p> <p>Complex queries allow for sophisticated search patterns, including graph traversals, relational filters, and embedding-based searches, combined into a single query operation.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>ComplexQuery</code> <p>A <code>ComplexQuery</code> object defining the components of the search, such as graph traversals, relational filters, and embedding searches.</p> required <p>Returns:</p> Name Type Description <code>QueryResult</code> <code>QueryResult</code> <p>A <code>QueryResult</code> object containing a list of matching</p> <code>QueryResult</code> <p><code>ObjectInstance</code>s and a list of any errors encountered during</p> <code>QueryResult</code> <p>query processing.</p> <p>Raises:</p> Type Description <code>NotConnectedError</code> <p>If the client is not connected to the database.</p> <code>GrizabellaException</code> <p>If there is an error during query planning or execution.</p> Source code in <code>grizabella/api/client.py</code> <pre><code>def execute_complex_query(self, query: ComplexQuery) -&gt; QueryResult:\n    \"\"\"Executes a complex query spanning multiple database layers.\n\n    Complex queries allow for sophisticated search patterns, including\n    graph traversals, relational filters, and embedding-based searches,\n    combined into a single query operation.\n\n    Args:\n        query (ComplexQuery): A ``ComplexQuery`` object defining the\n            components of the search, such as graph traversals,\n            relational filters, and embedding searches.\n\n    Returns:\n        QueryResult: A ``QueryResult`` object containing a list of matching\n        ``ObjectInstance``s and a list of any errors encountered during\n        query processing.\n\n    Raises:\n        NotConnectedError: If the client is not connected to the database.\n        GrizabellaException: If there is an error during query planning\n            or execution.\n\n    \"\"\"\n    if not self._is_connected:\n        raise DatabaseError(\"Database not connected. Call connect() before executing queries.\")\n\n    if hasattr(self._db_manager, \"process_complex_query\"):\n        return self._db_manager.process_complex_query(query)\n    # This indicates a missing implementation in the DBManager,\n    # which is a development-time issue.\n    # Raising NotImplementedError is more appropriate here.\n    msg = \"GrizabellaDBManager.process_complex_query not yet implemented.\"\n    raise NotImplementedError(\n        msg,\n    )\n</code></pre>"},{"location":"api/client/#grizabella.api.client.Grizabella.find_objects","title":"<code>find_objects(type_name, filter_criteria=None, limit=None)</code>","text":"<p>Finds objects of a given type, optionally matching filter criteria.</p> <p>Parameters:</p> Name Type Description Default <code>type_name</code> <code>str</code> <p>The name of the object type to search for.</p> required <code>filter_criteria</code> <code>Optional[Dict[str, Any]]</code> <p>A dictionary where keys are property names and values are the values to filter by. Only objects matching all criteria will be returned. Defaults to None (no filtering).</p> <code>None</code> <code>limit</code> <code>Optional[int]</code> <p>The maximum number of objects to return. Defaults to None (no limit).</p> <code>None</code> <p>Returns:</p> Type Description <code>list[ObjectInstance]</code> <p>List[ObjectInstance]: A list of object instances matching the</p> <code>list[ObjectInstance]</code> <p>criteria.</p> <p>Raises:</p> Type Description <code>GrizabellaException</code> <p>If the object type does not exist or if there is an error during the search.</p> <code>NotConnectedError</code> <p>If the client is not connected to the database.</p> Source code in <code>grizabella/api/client.py</code> <pre><code>def find_objects(\n    self,\n    type_name: str,\n    filter_criteria: Optional[dict[str, Any]] = None,\n    limit: Optional[int] = None,\n) -&gt; list[ObjectInstance]:\n    \"\"\"Finds objects of a given type, optionally matching filter criteria.\n\n    Args:\n        type_name (str): The name of the object type to search for.\n        filter_criteria (Optional[Dict[str, Any]]): A dictionary where\n            keys are property names and values are the values to filter by.\n            Only objects matching all criteria will be returned.\n            Defaults to None (no filtering).\n        limit (Optional[int]): The maximum number of objects to return.\n            Defaults to None (no limit).\n\n    Returns:\n        List[ObjectInstance]: A list of object instances matching the\n        criteria.\n\n    Raises:\n        GrizabellaException: If the object type does not exist or if there\n            is an error during the search.\n        NotConnectedError: If the client is not connected to the database.\n\n    \"\"\"\n    return self._db_manager.query_object_instances(\n        object_type_name=type_name,\n        conditions=filter_criteria or {},\n        limit=limit,\n    )\n</code></pre>"},{"location":"api/client/#grizabella.api.client.Grizabella.find_similar","title":"<code>find_similar(embedding_name, query_text, limit=5, filter_condition=None)</code>","text":"<p>Finds objects semantically similar to a given query text.</p> <p>Parameters:</p> Name Type Description Default <code>embedding_name</code> <code>str</code> <p>The name of the EmbeddingDefinition to use.</p> required <code>query_text</code> <code>str</code> <p>The text to find similar objects for.</p> required <code>limit</code> <code>int</code> <p>The maximum number of similar results to return. Defaults to 5.</p> <code>5</code> <code>filter_condition</code> <code>Optional[str]</code> <p>An SQL-like WHERE clause to pre-filter results.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[ObjectInstance]</code> <p>List[ObjectInstance]: A list of ObjectInstances that are semantically</p> <code>list[ObjectInstance]</code> <p>similar to the query_text, ordered by similarity.</p> <p>Raises:</p> Type Description <code>NotConnectedError</code> <p>If the client is not connected to the database.</p> <code>SchemaError</code> <p>If the specified EmbeddingDefinition is not found or is invalid.</p> <code>EmbeddingError</code> <p>If an error occurs during embedding generation or search.</p> <code>GrizabellaException</code> <p>For other underlying database or processing errors.</p> Source code in <code>grizabella/api/client.py</code> <pre><code>def find_similar(\n    self,\n    embedding_name: str,\n    query_text: str,\n    limit: int = 5,\n    filter_condition: Optional[str] = None,\n) -&gt; list[ObjectInstance]: # Changed return type to list[ObjectInstance] for simplicity in test\n    \"\"\"Finds objects semantically similar to a given query text.\n\n    Args:\n        embedding_name (str): The name of the EmbeddingDefinition to use.\n        query_text (str): The text to find similar objects for.\n        limit (int): The maximum number of similar results to return. Defaults to 5.\n        filter_condition (Optional[str]): An SQL-like WHERE clause to pre-filter results.\n\n    Returns:\n        List[ObjectInstance]: A list of ObjectInstances that are semantically\n        similar to the query_text, ordered by similarity.\n\n    Raises:\n        NotConnectedError: If the client is not connected to the database.\n        SchemaError: If the specified EmbeddingDefinition is not found or is invalid.\n        EmbeddingError: If an error occurs during embedding generation or search.\n        GrizabellaException: For other underlying database or processing errors.\n\n    \"\"\"\n    if not self._is_connected:\n        self._db_manager.connect()\n\n    ed = self._db_manager.get_embedding_definition(embedding_name)\n    if not ed:\n        msg = f\"EmbeddingDefinition '{embedding_name}' not found.\"\n        raise SchemaError(msg)\n\n    # Call the db_manager's method that can handle query_text\n    # This method in _InstanceManager returns raw results: list[dict[str, Any]]\n    # where dicts contain 'object_instance_id' and '_distance'\n    raw_results = self._db_manager.find_similar_objects_by_embedding(\n        embedding_definition_name=embedding_name,\n        query_text=query_text,\n        limit=limit,\n        retrieve_full_objects=False, # We need IDs and scores to process further\n        filter_condition=filter_condition,\n    )\n\n    if not raw_results:\n        return []\n\n    # We need to convert raw_results (list of dicts with id and score)\n    # into a list of ObjectInstance, similar to how find_objects_similar_to_instance does.\n    # The _process_raw_similarity_results method in DBManager is suitable.\n    # It expects a source_object_id for filtering, which is not applicable here.\n    # We'll adapt its logic or call it carefully.\n\n    # Let's get the target object type from the embedding definition\n    target_object_type_name = ed.object_type_name\n\n    # Re-implementing parts of _process_raw_similarity_results logic here\n    # as it's not directly callable with a query_text scenario (no source_object_id)\n\n    final_results_with_scores: list[tuple[ObjectInstance, float]] = []\n    result_ids_map: dict[uuid.UUID, float] = {}\n\n    for res in raw_results:\n        try:\n            obj_id_str = res.get(\"object_instance_id\")\n            if not obj_id_str:\n                continue\n            obj_id = uuid.UUID(obj_id_str)\n            score = float(res.get(\"_distance\", 0.0)) # LanceDB uses _distance\n            result_ids_map[obj_id] = score\n        except (ValueError, KeyError, TypeError) as e:\n            # self._db_manager._logger.warning(...) # Can't access logger directly\n            print(f\"Warning: Skipping result due to parsing error: {res}, error: {e}\") # Basic print for now\n            continue\n\n    if not result_ids_map:\n        return []\n\n    sorted_similar_items = sorted(result_ids_map.items(), key=lambda item: item[1])[:limit]\n    result_ids_to_fetch = [item[0] for item in sorted_similar_items]\n\n    if result_ids_to_fetch:\n        # Convert UUIDs to strings for get_objects_by_ids if it expects strings\n        # However, db_manager.get_objects_by_ids takes list[uuid.UUID]\n        fetched_objects = self._db_manager.get_objects_by_ids(\n            target_object_type_name, result_ids_to_fetch,\n        )\n        fetched_objects_map = {obj.id: obj for obj in fetched_objects}\n\n        for obj_id_val, _ in sorted_similar_items: # score_val not used in final list of ObjectInstance\n            if obj_id_val in fetched_objects_map:\n                final_results_with_scores.append(\n                    (fetched_objects_map[obj_id_val], _), # Keep score for potential future use\n                )\n\n    # Return only the ObjectInstances, ordered by similarity (which sorted_similar_items already did)\n    return [obj_inst for obj_inst, score in final_results_with_scores]\n</code></pre>"},{"location":"api/client/#grizabella.api.client.Grizabella.get_embedding_definition","title":"<code>get_embedding_definition(name)</code>","text":"<p>Retrieves an embedding definition by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the embedding definition to retrieve.</p> required <p>Returns:</p> Type Description <code>Optional[EmbeddingDefinition]</code> <p>Optional[EmbeddingDefinition]: The embedding definition if found,</p> <code>Optional[EmbeddingDefinition]</code> <p>otherwise None.</p> <p>Raises:</p> Type Description <code>NotConnectedError</code> <p>If the client is not connected to the database.</p> Source code in <code>grizabella/api/client.py</code> <pre><code>def get_embedding_definition(self, name: str) -&gt; Optional[EmbeddingDefinition]:\n    \"\"\"Retrieves an embedding definition by its name.\n\n    Args:\n        name (str): The name of the embedding definition to retrieve.\n\n    Returns:\n        Optional[EmbeddingDefinition]: The embedding definition if found,\n        otherwise None.\n\n    Raises:\n        NotConnectedError: If the client is not connected to the database.\n\n    \"\"\"\n    if not self._is_connected:\n        self._db_manager.connect()\n    return self._db_manager.get_embedding_definition(name)\n</code></pre>"},{"location":"api/client/#grizabella.api.client.Grizabella.get_incoming_relations","title":"<code>get_incoming_relations(object_id, type_name, relation_type_name=None)</code>","text":"<p>Retrieves all incoming relations to a given object.</p> <p>Parameters:</p> Name Type Description Default <code>object_id</code> <code>str</code> <p>The ID of the target object.</p> required <code>type_name</code> <code>str</code> <p>The type name of the target object. (Note: This parameter is not directly used by the underlying DBManager's <code>find_relation_instances</code> for this specific query but is kept for API consistency or future use).</p> required <code>relation_type_name</code> <code>Optional[str]</code> <p>If provided, filters relations by this specific relation type name. Defaults to None (no filter).</p> <code>None</code> <p>Returns:</p> Type Description <code>list[RelationInstance]</code> <p>List[RelationInstance]: A list of incoming relation instances.</p> <p>Raises:</p> Type Description <code>GrizabellaException</code> <p>If there is an error during retrieval.</p> <code>NotConnectedError</code> <p>If the client is not connected to the database.</p> <code>ValueError</code> <p>If <code>object_id</code> is not a valid UUID string.</p> Source code in <code>grizabella/api/client.py</code> <pre><code>def get_incoming_relations(\n    self, object_id: str, type_name: str, relation_type_name: Optional[str] = None, # pylint: disable=unused-argument\n) -&gt; list[RelationInstance]:\n    \"\"\"Retrieves all incoming relations to a given object.\n\n    Args:\n        object_id (str): The ID of the target object.\n        type_name (str): The type name of the target object. (Note: This\n            parameter is not directly used by the underlying DBManager's\n            `find_relation_instances` for this specific query but is kept\n            for API consistency or future use).\n        relation_type_name (Optional[str]): If provided, filters relations\n            by this specific relation type name. Defaults to None (no filter).\n\n    Returns:\n        List[RelationInstance]: A list of incoming relation instances.\n\n    Raises:\n        GrizabellaException: If there is an error during retrieval.\n        NotConnectedError: If the client is not connected to the database.\n        ValueError: If `object_id` is not a valid UUID string.\n\n    \"\"\"\n    if not self._is_connected:\n        self._db_manager.connect()  # Ensure connection\n    try:\n        target_uuid = uuid.UUID(object_id)\n    except ValueError as e:\n        msg = f\"Invalid UUID string for target_object_id: {object_id}\"\n        raise ValueError(\n            msg,\n        ) from e\n\n    return self._db_manager.find_relation_instances(\n        relation_type_name=relation_type_name, target_object_id=target_uuid,\n    )\n</code></pre>"},{"location":"api/client/#grizabella.api.client.Grizabella.get_object_by_id","title":"<code>get_object_by_id(object_id, type_name)</code>","text":"<p>Retrieves an object by its ID and type.</p> <p>Parameters:</p> Name Type Description Default <code>object_id</code> <code>str</code> <p>The unique identifier of the object.</p> required <code>type_name</code> <code>str</code> <p>The name of the object type.</p> required <p>Returns:</p> Type Description <code>Optional[ObjectInstance]</code> <p>Optional[ObjectInstance]: The object instance if found,</p> <code>Optional[ObjectInstance]</code> <p>otherwise None.</p> <p>Raises:</p> Type Description <code>GrizabellaException</code> <p>If the object type does not exist or if there is an error during retrieval.</p> <code>NotConnectedError</code> <p>If the client is not connected to the database.</p> Source code in <code>grizabella/api/client.py</code> <pre><code>def get_object_by_id(\n    self, object_id: str, type_name: str,\n) -&gt; Optional[ObjectInstance]:\n    \"\"\"Retrieves an object by its ID and type.\n\n    Args:\n        object_id (str): The unique identifier of the object.\n        type_name (str): The name of the object type.\n\n    Returns:\n        Optional[ObjectInstance]: The object instance if found,\n        otherwise None.\n\n    Raises:\n        GrizabellaException: If the object type does not exist or if there\n            is an error during retrieval.\n        NotConnectedError: If the client is not connected to the database.\n\n    \"\"\"\n    return self._db_manager.get_object_instance(\n        object_type_name=type_name, instance_id=object_id,\n    )\n</code></pre>"},{"location":"api/client/#grizabella.api.client.Grizabella.get_object_type_definition","title":"<code>get_object_type_definition(type_name)</code>","text":"<p>Retrieves the definition of an object type.</p> <p>Parameters:</p> Name Type Description Default <code>type_name</code> <code>str</code> <p>The name of the object type to retrieve.</p> required <p>Returns:</p> Type Description <code>Optional[ObjectTypeDefinition]</code> <p>Optional[ObjectTypeDefinition]: The definition of the object type</p> <code>Optional[ObjectTypeDefinition]</code> <p>if found, otherwise None.</p> <p>Raises:</p> Type Description <code>NotConnectedError</code> <p>If the client is not connected to the database.</p> Source code in <code>grizabella/api/client.py</code> <pre><code>def get_object_type_definition(\n    self, type_name: str,\n) -&gt; Optional[ObjectTypeDefinition]:\n    \"\"\"Retrieves the definition of an object type.\n\n    Args:\n        type_name (str): The name of the object type to retrieve.\n\n    Returns:\n        Optional[ObjectTypeDefinition]: The definition of the object type\n        if found, otherwise None.\n\n    Raises:\n        NotConnectedError: If the client is not connected to the database.\n\n    \"\"\"\n    return self._db_manager.get_object_type_definition(type_name)\n</code></pre>"},{"location":"api/client/#grizabella.api.client.Grizabella.get_outgoing_relations","title":"<code>get_outgoing_relations(object_id, type_name, relation_type_name=None)</code>","text":"<p>Retrieves all outgoing relations from a given object.</p> <p>Parameters:</p> Name Type Description Default <code>object_id</code> <code>str</code> <p>The ID of the source object.</p> required <code>type_name</code> <code>str</code> <p>The type name of the source object. (Note: This parameter is not directly used by the underlying DBManager's <code>find_relation_instances</code> for this specific query but is kept for API consistency or future use).</p> required <code>relation_type_name</code> <code>Optional[str]</code> <p>If provided, filters relations by this specific relation type name. Defaults to None (no filter).</p> <code>None</code> <p>Returns:</p> Type Description <code>list[RelationInstance]</code> <p>List[RelationInstance]: A list of outgoing relation instances.</p> <p>Raises:</p> Type Description <code>GrizabellaException</code> <p>If there is an error during retrieval.</p> <code>NotConnectedError</code> <p>If the client is not connected to the database.</p> <code>ValueError</code> <p>If <code>object_id</code> is not a valid UUID string.</p> Source code in <code>grizabella/api/client.py</code> <pre><code>def get_outgoing_relations(\n    self, object_id: str, type_name: str, relation_type_name: Optional[str] = None, # pylint: disable=unused-argument\n) -&gt; list[RelationInstance]:\n    \"\"\"Retrieves all outgoing relations from a given object.\n\n    Args:\n        object_id (str): The ID of the source object.\n        type_name (str): The type name of the source object. (Note: This\n            parameter is not directly used by the underlying DBManager's\n            `find_relation_instances` for this specific query but is kept\n            for API consistency or future use).\n        relation_type_name (Optional[str]): If provided, filters relations\n            by this specific relation type name. Defaults to None (no filter).\n\n    Returns:\n        List[RelationInstance]: A list of outgoing relation instances.\n\n    Raises:\n        GrizabellaException: If there is an error during retrieval.\n        NotConnectedError: If the client is not connected to the database.\n        ValueError: If `object_id` is not a valid UUID string.\n\n    \"\"\"\n    if not self._is_connected:\n        self._db_manager.connect()  # Ensure connection\n    try:\n        source_uuid = uuid.UUID(object_id)\n    except ValueError as e:\n        # It's generally better to let exceptions propagate or handle them more specifically.\n        # For now, re-raising to make it clear to the caller.\n        msg = f\"Invalid UUID string for source_object_id: {object_id}\"\n        raise ValueError(\n            msg,\n        ) from e\n\n    return self._db_manager.find_relation_instances(\n        relation_type_name=relation_type_name, source_object_id=source_uuid,\n    )\n</code></pre>"},{"location":"api/client/#grizabella.api.client.Grizabella.get_relation","title":"<code>get_relation(from_object_id, to_object_id, relation_type_name)</code>","text":"<p>Retrieves relation instances between two objects of a specific type.</p> Note <p>This method's current implementation in the client API differs from the underlying <code>GrizabellaDBManager</code> which expects a <code>relation_id</code>. This method currently raises <code>NotImplementedError</code> and requires rework to correctly map to the DBManager's capabilities or a change in the client API signature.</p> <p>Parameters:</p> Name Type Description Default <code>from_object_id</code> <code>str</code> <p>The ID of the source object of the relation.</p> required <code>to_object_id</code> <code>str</code> <p>The ID of the target object of the relation.</p> required <code>relation_type_name</code> <code>str</code> <p>The name of the relation type.</p> required <p>Returns:</p> Type Description <code>list[RelationInstance]</code> <p>List[RelationInstance]: A list of relation instances matching the criteria.</p> <code>list[RelationInstance]</code> <p>An empty list is returned if no matching relations are found.</p> <p>Raises:</p> Type Description <code>GrizabellaException</code> <p>If there is an error during retrieval.</p> <code>NotConnectedError</code> <p>If the client is not connected to the database.</p> <code>ValueError</code> <p>If <code>from_object_id</code> or <code>to_object_id</code> are not valid UUID strings.</p> Source code in <code>grizabella/api/client.py</code> <pre><code>def get_relation(\n    self, from_object_id: str, to_object_id: str, relation_type_name: str,\n) -&gt; list[RelationInstance]:\n    \"\"\"Retrieves relation instances between two objects of a specific type.\n\n    Note:\n        This method's current implementation in the client API differs\n        from the underlying `GrizabellaDBManager` which expects a\n        `relation_id`. This method currently raises `NotImplementedError`\n        and requires rework to correctly map to the DBManager's capabilities\n        or a change in the client API signature.\n\n    Args:\n        from_object_id (str): The ID of the source object of the relation.\n        to_object_id (str): The ID of the target object of the relation.\n        relation_type_name (str): The name of the relation type.\n\n    Returns:\n        List[RelationInstance]: A list of relation instances matching the criteria.\n        An empty list is returned if no matching relations are found.\n\n    Raises:\n        GrizabellaException: If there is an error during retrieval.\n        NotConnectedError: If the client is not connected to the database.\n        ValueError: If `from_object_id` or `to_object_id` are not valid UUID strings.\n\n    \"\"\"\n    if not self._is_connected:\n        self._db_manager.connect() # Ensure connection\n\n    try:\n        source_uuid = uuid.UUID(from_object_id)\n        target_uuid = uuid.UUID(to_object_id)\n    except ValueError as e:\n        msg = (\n            f\"Invalid UUID string for from_object_id ('{from_object_id}') or \"\n            f\"to_object_id ('{to_object_id}').\"\n        )\n        raise ValueError(\n            msg,\n        ) from e\n\n    return self._db_manager.find_relation_instances(\n        relation_type_name=relation_type_name,\n        source_object_id=source_uuid,\n        target_object_id=target_uuid,\n    )\n</code></pre>"},{"location":"api/client/#grizabella.api.client.Grizabella.get_relation_type","title":"<code>get_relation_type(type_name)</code>","text":"<p>Retrieves the definition of a relation type.</p> <p>Parameters:</p> Name Type Description Default <code>type_name</code> <code>str</code> <p>The name of the relation type to retrieve.</p> required <p>Returns:</p> Type Description <code>Optional[RelationTypeDefinition]</code> <p>Optional[RelationTypeDefinition]: The definition of the relation</p> <code>Optional[RelationTypeDefinition]</code> <p>type if found, otherwise None.</p> <p>Raises:</p> Type Description <code>NotConnectedError</code> <p>If the client is not connected to the database.</p> Source code in <code>grizabella/api/client.py</code> <pre><code>def get_relation_type(self, type_name: str) -&gt; Optional[RelationTypeDefinition]:\n    \"\"\"Retrieves the definition of a relation type.\n\n    Args:\n        type_name (str): The name of the relation type to retrieve.\n\n    Returns:\n        Optional[RelationTypeDefinition]: The definition of the relation\n        type if found, otherwise None.\n\n    Raises:\n        NotConnectedError: If the client is not connected to the database.\n\n    \"\"\"\n    return self._db_manager.get_relation_type_definition(type_name)\n</code></pre>"},{"location":"api/client/#grizabella.api.client.Grizabella.list_embedding_definitions","title":"<code>list_embedding_definitions()</code>","text":"<p>Lists all embedding definitions in the database.</p> <p>Returns:</p> Type Description <code>list[EmbeddingDefinition]</code> <p>List[EmbeddingDefinition]: A list of all embedding definitions.</p> <p>Raises:</p> Type Description <code>NotConnectedError</code> <p>If the client is not connected to the database.</p> Source code in <code>grizabella/api/client.py</code> <pre><code>def list_embedding_definitions(self) -&gt; list[EmbeddingDefinition]:\n    \"\"\"Lists all embedding definitions in the database.\n\n    Returns:\n        List[EmbeddingDefinition]: A list of all embedding definitions.\n\n    Raises:\n        NotConnectedError: If the client is not connected to the database.\n\n    \"\"\"\n    if not self._is_connected:\n        self._db_manager.connect()\n    return self._db_manager.list_embedding_definitions()\n</code></pre>"},{"location":"api/client/#grizabella.api.client.Grizabella.list_object_types","title":"<code>list_object_types()</code>","text":"<p>Lists all defined object types in the database.</p> <p>Returns:</p> Type Description <code>list[ObjectTypeDefinition]</code> <p>List[ObjectTypeDefinition]: A list of all object type definitions.</p> <p>Raises:</p> Type Description <code>NotConnectedError</code> <p>If the client is not connected to the database.</p> Source code in <code>grizabella/api/client.py</code> <pre><code>def list_object_types(self) -&gt; list[ObjectTypeDefinition]:\n    \"\"\"Lists all defined object types in the database.\n\n    Returns:\n        List[ObjectTypeDefinition]: A list of all object type definitions.\n\n    Raises:\n        NotConnectedError: If the client is not connected to the database.\n\n    \"\"\"\n    if not self._is_connected:\n        self._db_manager.connect()  # Ensure connection\n    return self._db_manager.list_object_type_definitions()\n</code></pre>"},{"location":"api/client/#grizabella.api.client.Grizabella.list_relation_types","title":"<code>list_relation_types()</code>","text":"<p>Lists all defined relation types in the database.</p> <p>Returns:</p> Type Description <code>list[RelationTypeDefinition]</code> <p>List[RelationTypeDefinition]: A list of all relation type definitions.</p> <p>Raises:</p> Type Description <code>NotConnectedError</code> <p>If the client is not connected to the database.</p> Source code in <code>grizabella/api/client.py</code> <pre><code>def list_relation_types(self) -&gt; list[RelationTypeDefinition]:\n    \"\"\"Lists all defined relation types in the database.\n\n    Returns:\n        List[RelationTypeDefinition]: A list of all relation type definitions.\n\n    Raises:\n        NotConnectedError: If the client is not connected to the database.\n\n    \"\"\"\n    if not self._is_connected:\n        self._db_manager.connect()  # Ensure connection\n    return self._db_manager.list_relation_type_definitions()\n</code></pre>"},{"location":"api/client/#grizabella.api.client.Grizabella.query_relations","title":"<code>query_relations(relation_type_name=None, source_object_instance_id=None, target_object_instance_id=None, properties_query=None, limit=None)</code>","text":"<p>Queries relation instances based on various criteria.</p> <p>Parameters:</p> Name Type Description Default <code>relation_type_name</code> <code>Optional[str]</code> <p>Filter by relation type name.</p> <code>None</code> <code>source_object_instance_id</code> <code>Optional[str]</code> <p>Filter by source object ID (UUID string).</p> <code>None</code> <code>target_object_instance_id</code> <code>Optional[str]</code> <p>Filter by target object ID (UUID string).</p> <code>None</code> <code>properties_query</code> <code>Optional[dict[str, Any]]</code> <p>Filter by relation properties.</p> <code>None</code> <code>limit</code> <code>Optional[int]</code> <p>Maximum number of results to return.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[RelationInstance]</code> <p>List[RelationInstance]: A list of matching relation instances.</p> <p>Raises:</p> Type Description <code>NotConnectedError</code> <p>If the client is not connected to the database.</p> <code>ValueError</code> <p>If provided UUID strings are invalid.</p> <code>GrizabellaException</code> <p>For other underlying database or processing errors.</p> Source code in <code>grizabella/api/client.py</code> <pre><code>def query_relations(\n    self,\n    relation_type_name: Optional[str] = None,\n    source_object_instance_id: Optional[str] = None,\n    target_object_instance_id: Optional[str] = None,\n    properties_query: Optional[dict[str, Any]] = None, # Matches 'query' in db_manager\n    limit: Optional[int] = None,\n) -&gt; list[RelationInstance]:\n    \"\"\"Queries relation instances based on various criteria.\n\n    Args:\n        relation_type_name (Optional[str]): Filter by relation type name.\n        source_object_instance_id (Optional[str]): Filter by source object ID (UUID string).\n        target_object_instance_id (Optional[str]): Filter by target object ID (UUID string).\n        properties_query (Optional[dict[str, Any]]): Filter by relation properties.\n        limit (Optional[int]): Maximum number of results to return.\n\n    Returns:\n        List[RelationInstance]: A list of matching relation instances.\n\n    Raises:\n        NotConnectedError: If the client is not connected to the database.\n        ValueError: If provided UUID strings are invalid.\n        GrizabellaException: For other underlying database or processing errors.\n\n    \"\"\"\n    if not self._is_connected:\n        self._db_manager.connect()  # Ensure connection\n\n    source_uuid: Optional[uuid.UUID] = None\n    if source_object_instance_id:\n        try:\n            source_uuid = uuid.UUID(source_object_instance_id)\n        except ValueError as e:\n            raise ValueError(f\"Invalid UUID string for source_object_instance_id: '{source_object_instance_id}'.\") from e\n\n    target_uuid: Optional[uuid.UUID] = None\n    if target_object_instance_id:\n        try:\n            target_uuid = uuid.UUID(target_object_instance_id)\n        except ValueError as e:\n            raise ValueError(f\"Invalid UUID string for target_object_instance_id: '{target_object_instance_id}'.\") from e\n\n    return self._db_manager.find_relation_instances(\n        relation_type_name=relation_type_name,\n        source_object_id=source_uuid, # Pass UUID object\n        target_object_id=target_uuid, # Pass UUID object\n        query=properties_query,\n        limit=limit,\n    )\n</code></pre>"},{"location":"api/client/#grizabella.api.client.Grizabella.search_similar_objects","title":"<code>search_similar_objects(object_id, type_name, n_results=5, search_properties=None)</code>","text":"<p>Searches for objects similar to a given object using its embeddings.</p> <p>This method finds objects of the same type as the source object that are semantically similar, based on a specified or inferred embedding definition.</p> <p>Parameters:</p> Name Type Description Default <code>object_id</code> <code>str</code> <p>The ID of the source object to find similar items for.</p> required <code>type_name</code> <code>str</code> <p>The type name of the source object.</p> required <code>n_results</code> <code>int</code> <p>The maximum number of similar results to return. Defaults to 5.</p> <code>5</code> <code>search_properties</code> <code>Optional[List[str]]</code> <p>If provided, the first element is used as the specific <code>embedding_definition_name</code> to use for both the source object's vector retrieval and the target search. If None or empty, the first available <code>EmbeddingDefinition</code> for the <code>type_name</code> will be used.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[tuple[ObjectInstance, float]]</code> <p>List[Tuple[ObjectInstance, float]]: A list of tuples, where each</p> <code>list[tuple[ObjectInstance, float]]</code> <p>tuple contains a similar <code>ObjectInstance</code> and its similarity score</p> <code>list[tuple[ObjectInstance, float]]</code> <p>(typically distance, where lower is more similar).</p> <p>Raises:</p> Type Description <code>NotConnectedError</code> <p>If the client is not connected to the database.</p> <code>ValueError</code> <p>If <code>object_id</code> is not a valid UUID string.</p> <code>SchemaError</code> <p>If a suitable <code>EmbeddingDefinition</code> cannot be found.</p> <code>EmbeddingError</code> <p>If an embedding for the source object cannot be found.</p> <code>GrizabellaException</code> <p>For other underlying database or processing errors.</p> Source code in <code>grizabella/api/client.py</code> <pre><code>def search_similar_objects(\n    self,\n    object_id: str,\n    type_name: str,\n    n_results: int = 5,\n    search_properties: Optional[list[str]] = None,\n) -&gt; list[tuple[ObjectInstance, float]]:\n    \"\"\"Searches for objects similar to a given object using its embeddings.\n\n    This method finds objects of the same type as the source object that\n    are semantically similar, based on a specified or inferred embedding definition.\n\n    Args:\n        object_id (str): The ID of the source object to find similar items for.\n        type_name (str): The type name of the source object.\n        n_results (int): The maximum number of similar results to return.\n            Defaults to 5.\n        search_properties (Optional[List[str]]): If provided, the first element\n            is used as the specific `embedding_definition_name` to use for both\n            the source object's vector retrieval and the target search.\n            If None or empty, the first available `EmbeddingDefinition` for the\n            `type_name` will be used.\n\n    Returns:\n        List[Tuple[ObjectInstance, float]]: A list of tuples, where each\n        tuple contains a similar `ObjectInstance` and its similarity score\n        (typically distance, where lower is more similar).\n\n    Raises:\n        NotConnectedError: If the client is not connected to the database.\n        ValueError: If `object_id` is not a valid UUID string.\n        SchemaError: If a suitable `EmbeddingDefinition` cannot be found.\n        EmbeddingError: If an embedding for the source object cannot be found.\n        GrizabellaException: For other underlying database or processing errors.\n\n    \"\"\"\n    if not self._is_connected:\n        self._db_manager.connect()\n\n    try:\n        source_uuid = uuid.UUID(object_id)\n    except ValueError as e:\n        msg = f\"Invalid UUID string for object_id: '{object_id}'.\"\n        raise ValueError(msg) from e\n\n    embedding_definition_name: Optional[str] = None\n    if search_properties and search_properties[0]:\n        embedding_definition_name = search_properties[0]\n        # Validate this ED exists and is for the correct object type\n        ed = self._db_manager.get_embedding_definition(embedding_definition_name)\n        if not ed:\n            msg = f\"Specified EmbeddingDefinition '{embedding_definition_name}' not found.\"\n            raise SchemaError(\n                msg,\n            )\n        if ed.object_type_name != type_name:\n            msg = (\n                f\"Specified EmbeddingDefinition '{embedding_definition_name}' is for object type \"\n                f\"'{ed.object_type_name}', but expected type '{type_name}' for object '{object_id}'.\"\n            )\n            raise SchemaError(\n                msg,\n            )\n    else:\n        # Find the first available EmbeddingDefinition for the type_name\n        all_eds = self._db_manager.list_embedding_definitions()\n        for ed in all_eds:\n            if ed.object_type_name == type_name:\n                embedding_definition_name = ed.name\n                break\n        if not embedding_definition_name:\n            msg = (\n                f\"No EmbeddingDefinition found for object type '{type_name}'. \"\n                \"Cannot perform similarity search.\"\n            )\n            raise SchemaError(\n                msg,\n            )\n\n    return self._db_manager.find_objects_similar_to_instance(\n        source_object_id=source_uuid,\n        source_object_type_name=type_name,\n        embedding_definition_name=embedding_definition_name,\n        n_results=n_results,\n    )\n</code></pre>"},{"location":"api/client/#grizabella.api.client.Grizabella.upsert_object","title":"<code>upsert_object(obj)</code>","text":"<p>Creates a new object or updates an existing one.</p> <p>If an object with the same ID already exists, it will be updated with the properties from the provided <code>ObjectInstance</code>. Otherwise, a new object will be created.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>ObjectInstance</code> <p>The object instance to create or update. It must include the object type name and its properties. The <code>id</code> field can be provided for updates or will be generated for new objects if not supplied.</p> required <p>Returns:</p> Name Type Description <code>ObjectInstance</code> <code>ObjectInstance</code> <p>The created or updated object instance, potentially</p> <code>ObjectInstance</code> <p>with a newly assigned ID or updated timestamps.</p> <p>Raises:</p> Type Description <code>GrizabellaException</code> <p>If the object type does not exist or if there is an error during the upsert operation.</p> <code>NotConnectedError</code> <p>If the client is not connected to the database.</p> Source code in <code>grizabella/api/client.py</code> <pre><code>def upsert_object(self, obj: ObjectInstance) -&gt; ObjectInstance:\n    \"\"\"Creates a new object or updates an existing one.\n\n    If an object with the same ID already exists, it will be updated\n    with the properties from the provided `ObjectInstance`. Otherwise, a\n    new object will be created.\n\n    Args:\n        obj (ObjectInstance): The object instance to create or update.\n            It must include the object type name and its properties.\n            The `id` field can be provided for updates or will be\n            generated for new objects if not supplied.\n\n    Returns:\n        ObjectInstance: The created or updated object instance, potentially\n        with a newly assigned ID or updated timestamps.\n\n    Raises:\n        GrizabellaException: If the object type does not exist or if there\n            is an error during the upsert operation.\n        NotConnectedError: If the client is not connected to the database.\n\n    \"\"\"\n    return self._db_manager.upsert_object_instance(obj)\n</code></pre>"},{"location":"api/core_models/","title":"Core Models","text":""},{"location":"api/core_models/#grizabella.core.models","title":"<code>grizabella.core.models</code>","text":"<p>Core Pydantic models for Grizabella schema definitions and instances.</p>"},{"location":"api/core_models/#grizabella.core.models.EmbeddingDefinition","title":"<code>EmbeddingDefinition</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines how an embedding should be generated and stored for an <code>ObjectTypeDefinition</code>.</p> <p>This model specifies the configuration for creating vector embeddings from the content of objects. It links an object type and one of its properties to an embedding model.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>:noindex: A unique name for this embedding configuration (e.g., 'content_embedding_v1'). Conventionally, snake_case is used.</p> <code>object_type_name</code> <code>str</code> <p>:noindex: The name of the <code>ObjectTypeDefinition</code> this embedding applies to.</p> <code>source_property_name</code> <code>str</code> <p>:noindex: The name of the property within the specified <code>ObjectTypeDefinition</code> whose content will be used to generate the embedding.</p> <code>embedding_model</code> <code>str</code> <p>:noindex: An identifier for the embedding model to be used (e.g., a Hugging Face model name like 'huggingface/mixedbread-ai/mxbai-embed-large-v1').</p> <code>dimensions</code> <code>Optional[int]</code> <p>:noindex: The expected dimensionality of the embedding vector. If None, the system may attempt to infer it from the model.</p> <code>description</code> <code>Optional[str]</code> <p>:noindex: An optional human-readable description of this embedding definition.</p> Source code in <code>grizabella/core/models.py</code> <pre><code>class EmbeddingDefinition(BaseModel):\n    \"\"\"Defines how an embedding should be generated and stored for an ``ObjectTypeDefinition``.\n\n    This model specifies the configuration for creating vector embeddings from\n    the content of objects. It links an object type and one of its properties\n    to an embedding model.\n\n    Attributes:\n        name (str): :noindex: A unique name for this embedding configuration (e.g.,\n            'content_embedding_v1'). Conventionally, snake_case is used.\n\n        object_type_name (str): :noindex: The name of the ``ObjectTypeDefinition`` this\n            embedding applies to.\n\n        source_property_name (str): :noindex: The name of the property within the\n            specified ``ObjectTypeDefinition`` whose content will be used to\n            generate the embedding.\n\n        embedding_model (str): :noindex: An identifier for the embedding model to be\n            used (e.g., a Hugging Face model name like\n            'huggingface/mixedbread-ai/mxbai-embed-large-v1').\n\n        dimensions (Optional[int]): :noindex: The expected dimensionality of the\n            embedding vector. If None, the system may attempt to infer it\n            from the model.\n\n        description (Optional[str]): :noindex: An optional human-readable description\n            of this embedding definition.\n\n\n    \"\"\"\n\n    name: str = Field(\n        ...,\n        description=(\n            \"Unique name for this embedding configuration \"\n            \"(e.g., 'content_embedding_v1'). Convention: snake_case.\"\n        ),\n    )\n    object_type_name: str = Field(\n        ...,\n        description=\"Name of the ObjectTypeDefinition this embedding applies to.\",\n    )\n    source_property_name: str = Field(\n        ...,\n        description=(\n            \"Name of the property within the ObjectTypeDefinition whose content will be \"\n            \"embedded.\"\n        ),\n    )\n    embedding_model: str = Field(\n        default=\"huggingface/mixedbread-ai/mxbai-embed-large-v1\",\n        description=\"Identifier for the embedding model to use.\",\n    )\n    dimensions: Optional[int] = Field(\n        default=None,\n        description=\"Expected dimensions of the embedding vector. If None, inferred from model.\",\n    )\n    description: Optional[str] = Field(\n        default=None,\n        description=\"Optional description of this embedding definition.\",\n    )\n</code></pre>"},{"location":"api/core_models/#grizabella.core.models.EmbeddingInstance","title":"<code>EmbeddingInstance</code>","text":"<p>               Bases: <code>MemoryInstance</code></p> <p>Represents an instance of an embedding, linked to an <code>ObjectInstance</code>.</p> <p>This model stores a vector embedding generated from a specific property of an <code>ObjectInstance</code>, according to an <code>EmbeddingDefinition</code>. It inherits common metadata fields from <code>MemoryInstance</code>.</p> <p>Attributes:</p> Name Type Description <code>object_instance_id</code> <code>UUID</code> <p>:noindex: The ID of the <code>ObjectInstance</code> to which this embedding belongs.</p> <code>embedding_definition_name</code> <code>str</code> <p>:noindex: The name of the <code>EmbeddingDefinition</code> that was used to generate this embedding.</p> <code>vector</code> <code>List[float]</code> <p>:noindex: The actual embedding vector, represented as a list of floating-point numbers.</p> <code>source_text_preview</code> <code>Optional[str]</code> <p>:noindex: A truncated preview of the source text that was used to generate the embedding. This can be useful for quick inspection or debugging.</p> Source code in <code>grizabella/core/models.py</code> <pre><code>class EmbeddingInstance(MemoryInstance):\n    \"\"\"Represents an instance of an embedding, linked to an ``ObjectInstance``.\n\n    This model stores a vector embedding generated from a specific property of\n    an ``ObjectInstance``, according to an ``EmbeddingDefinition``. It inherits\n    common metadata fields from ``MemoryInstance``.\n\n    Attributes:\n        object_instance_id (UUID): :noindex: The ID of the ``ObjectInstance`` to which\n            this embedding belongs.\n\n        embedding_definition_name (str): :noindex: The name of the ``EmbeddingDefinition``\n            that was used to generate this embedding.\n\n        vector (List[float]): :noindex: The actual embedding vector, represented as a\n            list of floating-point numbers.\n\n        source_text_preview (Optional[str]): :noindex: A truncated preview of the source\n            text that was used to generate the embedding. This can be useful\n            for quick inspection or debugging.\n\n\n    \"\"\"\n\n    object_instance_id: UUID = Field(\n        ...,\n        description=\"ID of the ObjectInstance this embedding belongs to.\",\n    )\n    embedding_definition_name: str = Field(\n        ...,\n        description=\"Name of the EmbeddingDefinition used to generate this embedding.\",\n    )\n    vector: list[float] = Field(\n        ...,\n        description=\"The embedding vector.\",\n    )\n    source_text_preview: Optional[str] = Field(\n        default=None,\n        description=\"A truncated preview of the source text used for embedding.\",\n    )\n</code></pre>"},{"location":"api/core_models/#grizabella.core.models.MemoryInstance","title":"<code>MemoryInstance</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base model for all storable instances, providing common metadata.</p> <p>This model includes fields that are common to all persistent entities within Grizabella, such as a unique identifier, a weight for ranking or relevance, and an upsert timestamp.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>UUID</code> <p>:noindex: A unique identifier for the instance, generated by default.</p> <code>weight</code> <code>condecimal</code> <p>:noindex: A decimal value between 0 and 10 (inclusive) representing the importance or relevance of the instance. Used for ranking or filtering. Defaults to 1.0.</p> <code>upsert_date</code> <code>datetime</code> <p>:noindex: The timestamp (UTC) when the instance was last created or updated. Automatically set on creation/update.</p> Source code in <code>grizabella/core/models.py</code> <pre><code>class MemoryInstance(BaseModel):\n    \"\"\"Base model for all storable instances, providing common metadata.\n\n    This model includes fields that are common to all persistent entities\n    within Grizabella, such as a unique identifier, a weight for ranking or\n    relevance, and an upsert timestamp.\n\n    Attributes:\n        id (UUID): :noindex: A unique identifier for the instance, generated by default.\n\n        weight (condecimal): :noindex: A decimal value between 0 and 10 (inclusive)\n            representing the importance or relevance of the instance.\n            Used for ranking or filtering. Defaults to 1.0.\n\n        upsert_date (datetime): :noindex: The timestamp (UTC) when the instance was\n            last created or updated. Automatically set on creation/update.\n\n\n    \"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    weight: Decimal = Field(default=Decimal(\"1.0\"), ge=0, le=10)\n    upsert_date: datetime = Field(\n        default_factory=lambda: datetime.now(timezone.utc),\n    )\n\n    model_config = ConfigDict( # pylint: disable=R0903\n        validate_assignment=True, # Ensure fields are validated on assignment\n        arbitrary_types_allowed=True, # To allow condecimal\n    )\n</code></pre>"},{"location":"api/core_models/#grizabella.core.models.ObjectInstance","title":"<code>ObjectInstance</code>","text":"<p>               Bases: <code>MemoryInstance</code></p> <p>Represents a concrete instance of an <code>ObjectTypeDefinition</code>.</p> <p>This model holds the actual data for an individual object, conforming to the schema defined by its <code>ObjectTypeDefinition</code>. It inherits common metadata fields from <code>MemoryInstance</code>.</p> <p>Attributes:</p> Name Type Description <code>object_type_name</code> <code>str</code> <p>:noindex: The name of the <code>ObjectTypeDefinition</code> that this instance conforms to.</p> <code>properties</code> <code>Dict[str, Any]</code> <p>:noindex: A dictionary containing the actual data for the instance, mapping property names (as defined in the <code>ObjectTypeDefinition</code>) to their corresponding values.</p> Source code in <code>grizabella/core/models.py</code> <pre><code>class ObjectInstance(MemoryInstance):\n    \"\"\"Represents a concrete instance of an ``ObjectTypeDefinition``.\n\n    This model holds the actual data for an individual object, conforming to\n    the schema defined by its ``ObjectTypeDefinition``. It inherits common\n    metadata fields from ``MemoryInstance``.\n\n    Attributes:\n        object_type_name (str): :noindex: The name of the ``ObjectTypeDefinition`` that\n            this instance conforms to.\n\n        properties (Dict[str, Any]): :noindex: A dictionary containing the actual data\n            for the instance, mapping property names (as defined in the\n            ``ObjectTypeDefinition``) to their corresponding values.\n\n\n    \"\"\"\n\n    object_type_name: str = Field(\n        ...,\n        description=\"Name of the ObjectTypeDefinition this instance conforms to.\",\n    )\n    properties: dict[str, Any] = Field(\n        ...,\n        description=\"Actual data for the instance, mapping property names to values.\",\n    )\n\n    @model_validator(mode='after')\n    def _convert_datetime_strings(self) -&gt; 'ObjectInstance':\n        \"\"\"Convert ISO format datetime strings in properties back to datetime objects.\"\"\"\n        if not isinstance(self.properties, dict):\n            return self\n\n        for key, value in self.properties.items():\n            # Check if the value is a string that looks like an ISO datetime\n            if isinstance(value, str):\n                # Try to parse as ISO format datetime\n                try:\n                    # Handle various ISO datetime formats\n                    if 'T' in value and ('+' in value or value.endswith('Z') or value.count(':') &gt;= 2):\n                        parsed_dt = datetime.fromisoformat(value)\n                        self.properties[key] = parsed_dt\n                except (ValueError, TypeError):\n                    # If parsing fails, leave as string\n                    pass\n        return self\n\n    model_config = ConfigDict(validate_assignment=True)\n</code></pre>"},{"location":"api/core_models/#grizabella.core.models.ObjectTypeDefinition","title":"<code>ObjectTypeDefinition</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines the schema for a type of object (e.g., a node in a graph, a table row).</p> <p>An <code>ObjectTypeDefinition</code> specifies the structure for a category of data entities. It includes a unique name, an optional description, and a list of <code>PropertyDefinition</code>s that define its attributes.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>:noindex: A unique name for the object type (e.g., 'Document', 'Person'). Conventionally, PascalCase is used.</p> <code>description</code> <code>Optional[str]</code> <p>:noindex: An optional human-readable description of what this object type represents.</p> <code>properties</code> <code>List[PropertyDefinition]</code> <p>:noindex: A list of properties that define the attributes of this object type.</p> Source code in <code>grizabella/core/models.py</code> <pre><code>class ObjectTypeDefinition(BaseModel):\n    \"\"\"Defines the schema for a type of object (e.g., a node in a graph, a table row).\n\n    An ``ObjectTypeDefinition`` specifies the structure for a category of data\n    entities. It includes a unique name, an optional description, and a list\n    of ``PropertyDefinition``s that define its attributes.\n\n    Attributes:\n        name (str): :noindex: A unique name for the object type (e.g., 'Document',\n            'Person'). Conventionally, PascalCase is used.\n\n        description (Optional[str]): :noindex: An optional human-readable description\n            of what this object type represents.\n\n        properties (List[PropertyDefinition]): :noindex: A list of properties that\n            define the attributes of this object type.\n\n\n    \"\"\"\n\n    name: str = Field(\n        ...,\n        description=(\n            \"Unique name for the object type (e.g., 'Document', 'Person'). \"\n            \"Convention: PascalCase.\"\n        ),\n    )\n    description: Optional[str] = Field(\n        default=None,\n        description=\"Optional description of the object type.\",\n    )\n    properties: list[PropertyDefinition] = Field(\n        ...,\n        description=\"List of properties defining this object type.\",\n    )\n    # _created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))\n    # _updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))\n\n    @field_validator(\"properties\")\n    @classmethod\n    def check_primary_key_once(\n        cls, v: list[PropertyDefinition],\n    ) -&gt; list[PropertyDefinition]:\n        \"\"\"Ensures that an ObjectTypeDefinition has at most one primary key.\n\n        While the `id` field from `MemoryInstance` serves as a unique identifier\n        for `ObjectInstance`s, an `ObjectTypeDefinition` can optionally define\n        one of its properties as a primary key for domain-specific identification\n        or for database layers that require an explicit primary key column.\n\n        Args:\n            v (List[PropertyDefinition]): The list of properties being validated.\n\n        Returns:\n            List[PropertyDefinition]: The validated list of properties.\n\n        Raises:\n            ValueError: If more than one property is marked as `is_primary_key`.\n\n        \"\"\"\n        pk_count = sum(1 for p in v if p.is_primary_key)\n        if pk_count &gt; 1:\n            msg = \"An ObjectTypeDefinition can have at most one primary key property.\"\n            raise ValueError(\n                msg,\n            )\n        # If no explicit PK, 'id' from MemoryInstance will serve this role for ObjectInstance\n        return v\n\n    # Workaround for FastMCP schema registration\n    model_config = ConfigDict(extra=\"allow\")\n\n    # Workaround for FastMCP schema registration\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/core_models/#grizabella.core.models.ObjectTypeDefinition.check_primary_key_once","title":"<code>check_primary_key_once(v)</code>  <code>classmethod</code>","text":"<p>Ensures that an ObjectTypeDefinition has at most one primary key.</p> <p>While the <code>id</code> field from <code>MemoryInstance</code> serves as a unique identifier for <code>ObjectInstance</code>s, an <code>ObjectTypeDefinition</code> can optionally define one of its properties as a primary key for domain-specific identification or for database layers that require an explicit primary key column.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>List[PropertyDefinition]</code> <p>The list of properties being validated.</p> required <p>Returns:</p> Type Description <code>list[PropertyDefinition]</code> <p>List[PropertyDefinition]: The validated list of properties.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If more than one property is marked as <code>is_primary_key</code>.</p> Source code in <code>grizabella/core/models.py</code> <pre><code>@field_validator(\"properties\")\n@classmethod\ndef check_primary_key_once(\n    cls, v: list[PropertyDefinition],\n) -&gt; list[PropertyDefinition]:\n    \"\"\"Ensures that an ObjectTypeDefinition has at most one primary key.\n\n    While the `id` field from `MemoryInstance` serves as a unique identifier\n    for `ObjectInstance`s, an `ObjectTypeDefinition` can optionally define\n    one of its properties as a primary key for domain-specific identification\n    or for database layers that require an explicit primary key column.\n\n    Args:\n        v (List[PropertyDefinition]): The list of properties being validated.\n\n    Returns:\n        List[PropertyDefinition]: The validated list of properties.\n\n    Raises:\n        ValueError: If more than one property is marked as `is_primary_key`.\n\n    \"\"\"\n    pk_count = sum(1 for p in v if p.is_primary_key)\n    if pk_count &gt; 1:\n        msg = \"An ObjectTypeDefinition can have at most one primary key property.\"\n        raise ValueError(\n            msg,\n        )\n    # If no explicit PK, 'id' from MemoryInstance will serve this role for ObjectInstance\n    return v\n</code></pre>"},{"location":"api/core_models/#grizabella.core.models.PropertyDataType","title":"<code>PropertyDataType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumeration of supported data types for object and relation properties.</p> <p>This enum defines the set of primitive data types that can be used when defining properties for <code>ObjectTypeDefinition</code> and <code>RelationTypeDefinition</code>. These types guide data validation and storage.</p> <p>Attributes:</p> Name Type Description <code>TEXT</code> <p>A string of text.</p> <code>INTEGER</code> <p>A whole number.</p> <code>FLOAT</code> <p>A floating-point number.</p> <code>BOOLEAN</code> <p>A true or false value.</p> <code>DATETIME</code> <p>A date and time value, typically stored in UTC.</p> <code>BLOB</code> <p>Binary Large Object, for storing raw binary data.</p> <code>JSON</code> <p>A JSON object or array, for semi-structured data.</p> <code>UUID</code> <p>A universally unique identifier.</p> Source code in <code>grizabella/core/models.py</code> <pre><code>class PropertyDataType(str, Enum):\n    \"\"\"Enumeration of supported data types for object and relation properties.\n\n    This enum defines the set of primitive data types that can be used when\n    defining properties for `ObjectTypeDefinition` and `RelationTypeDefinition`.\n    These types guide data validation and storage.\n\n    Attributes:\n        TEXT: A string of text.\n        INTEGER: A whole number.\n        FLOAT: A floating-point number.\n        BOOLEAN: A true or false value.\n        DATETIME: A date and time value, typically stored in UTC.\n        BLOB: Binary Large Object, for storing raw binary data.\n        JSON: A JSON object or array, for semi-structured data.\n        UUID: A universally unique identifier.\n\n    \"\"\"\n\n    TEXT = \"TEXT\"\n    INTEGER = \"INTEGER\"\n    FLOAT = \"FLOAT\"\n    BOOLEAN = \"BOOLEAN\"\n    DATETIME = \"DATETIME\"\n    BLOB = \"BLOB\"\n    JSON = \"JSON\"\n    UUID = \"UUID\" # For explicit UUID type properties\n</code></pre>"},{"location":"api/core_models/#grizabella.core.models.PropertyDefinition","title":"<code>PropertyDefinition</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines a single property within an <code>ObjectTypeDefinition</code> or <code>RelationTypeDefinition</code>.</p> <p>This model specifies the characteristics of a property, such as its name, data type, and constraints (e.g., nullable, unique, indexed).</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>:noindex: The name of the property (e.g., 'title', 'age'). This name is used to access the property's value in instances.</p> <code>data_type</code> <code>PropertyDataType</code> <p>:noindex: The data type of the property.</p> <code>is_primary_key</code> <code>bool</code> <p>:noindex: Indicates if this property serves as a primary key for its <code>ObjectTypeDefinition</code>. Defaults to False. An <code>ObjectTypeDefinition</code> can have at most one primary key.</p> <code>is_nullable</code> <code>bool</code> <p>:noindex: Specifies whether this property can have a null value. Defaults to True.</p> <code>is_indexed</code> <code>bool</code> <p>:noindex: Indicates if this property should be indexed by supporting database layers to speed up queries. Defaults to False.</p> <code>is_unique</code> <code>bool</code> <p>:noindex: Specifies whether values for this property must be unique across all instances of its <code>ObjectTypeDefinition</code>. Defaults to False.</p> <code>description</code> <code>Optional[str]</code> <p>:noindex: An optional human-readable description of the property.</p> Source code in <code>grizabella/core/models.py</code> <pre><code>class PropertyDefinition(BaseModel):\n    \"\"\"Defines a single property within an `ObjectTypeDefinition` or `RelationTypeDefinition`.\n\n    This model specifies the characteristics of a property, such as its name,\n    data type, and constraints (e.g., nullable, unique, indexed).\n\n    Attributes:\n        name (str): :noindex: The name of the property (e.g., 'title', 'age').\n            This name is used to access the property's value in instances.\n\n        data_type (PropertyDataType): :noindex: The data type of the property.\n\n        is_primary_key (bool): :noindex: Indicates if this property serves as a primary\n            key for its ``ObjectTypeDefinition``. Defaults to False.\n            An ``ObjectTypeDefinition`` can have at most one primary key.\n\n        is_nullable (bool): :noindex: Specifies whether this property can have a null\n            value. Defaults to True.\n\n        is_indexed (bool): :noindex: Indicates if this property should be indexed by\n            supporting database layers to speed up queries. Defaults to False.\n\n        is_unique (bool): :noindex: Specifies whether values for this property must be\n            unique across all instances of its ``ObjectTypeDefinition``.\n            Defaults to False.\n\n        description (Optional[str]): :noindex: An optional human-readable description\n            of the property.\n\n\n    \"\"\"\n\n    name: str = Field(\n        ...,\n        description=\"Name of the property (e.g., 'title', 'age').\",\n    )\n    data_type: PropertyDataType = Field(\n        ...,\n        description=\"Data type of the property.\",\n    )\n    is_primary_key: bool = Field(\n        default=False,\n        description=\"Is this property a primary key for the object type?\",\n    )\n    is_nullable: bool = Field(\n        default=True,\n        description=\"Can this property be null?\",\n    )\n    is_indexed: bool = Field(\n        default=False,\n        description=\"Should this property be indexed in supporting databases?\",\n    )\n    is_unique: bool = Field(\n        default=False,\n        description=\"Does this property require unique values?\",\n    )\n    description: Optional[str] = Field(\n        default=None,\n        description=\"Optional description of the property.\",\n    )\n</code></pre>"},{"location":"api/core_models/#grizabella.core.models.RelationInstance","title":"<code>RelationInstance</code>","text":"<p>               Bases: <code>MemoryInstance</code></p> <p>Represents a concrete instance of a <code>RelationTypeDefinition</code>, linking two <code>ObjectInstance</code>s.</p> <p>This model captures a specific relationship between two objects, conforming to the schema defined by its <code>RelationTypeDefinition</code>. It inherits common metadata fields from <code>MemoryInstance</code>.</p> <p>Attributes:</p> Name Type Description <code>relation_type_name</code> <code>str</code> <p>:noindex: The name of the <code>RelationTypeDefinition</code> that this instance conforms to.</p> <code>source_object_instance_id</code> <code>UUID</code> <p>:noindex: The ID of the <code>ObjectInstance</code> that is the source (or \"from\" side) of this relation.</p> <code>target_object_instance_id</code> <code>UUID</code> <p>:noindex: The ID of the <code>ObjectInstance</code> that is the target (or \"to\" side) of this relation.</p> <code>properties</code> <code>Dict[str, Any]</code> <p>:noindex: A dictionary containing the actual data for the relation's own properties (edge properties), if any are defined in its <code>RelationTypeDefinition</code>. Defaults to an empty dict.</p> Source code in <code>grizabella/core/models.py</code> <pre><code>class RelationInstance(MemoryInstance):\n    \"\"\"Represents a concrete instance of a ``RelationTypeDefinition``, linking two ``ObjectInstance``s.\n\n    This model captures a specific relationship between two objects, conforming\n    to the schema defined by its ``RelationTypeDefinition``. It inherits common\n    metadata fields from ``MemoryInstance``.\n\n    Attributes:\n        relation_type_name (str): :noindex: The name of the ``RelationTypeDefinition``\n            that this instance conforms to.\n\n        source_object_instance_id (UUID): :noindex: The ID of the ``ObjectInstance`` that\n            is the source (or \"from\" side) of this relation.\n\n        target_object_instance_id (UUID): :noindex: The ID of the ``ObjectInstance`` that\n            is the target (or \"to\" side) of this relation.\n\n        properties (Dict[str, Any]): :noindex: A dictionary containing the actual data\n            for the relation's own properties (edge properties), if any are\n            defined in its ``RelationTypeDefinition``. Defaults to an empty dict.\n\n\n    \"\"\"\n\n    relation_type_name: str = Field(\n        ...,\n        description=\"Name of the RelationTypeDefinition this instance conforms to.\",\n    )\n    source_object_instance_id: UUID = Field(\n        ...,\n        description=\"ID of the source ObjectInstance.\",\n    )\n    target_object_instance_id: UUID = Field(\n        ...,\n        description=\"ID of the target ObjectInstance.\",\n    )\n    properties: dict[str, Any] = Field(\n        default_factory=dict,\n        description=\"Actual data for the relation's properties.\",\n    )\n</code></pre>"},{"location":"api/core_models/#grizabella.core.models.RelationInstanceList","title":"<code>RelationInstanceList</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A container for a list of RelationInstance objects.</p> Source code in <code>grizabella/core/models.py</code> <pre><code>class RelationInstanceList(BaseModel):\n    \"\"\"A container for a list of RelationInstance objects.\"\"\"\n\n    relations: list[RelationInstance]\n</code></pre>"},{"location":"api/core_models/#grizabella.core.models.RelationTypeDefinition","title":"<code>RelationTypeDefinition</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines the schema for a type of relation between objects (e.g., an edge in a graph).</p> <p>A <code>RelationTypeDefinition</code> specifies the structure for relationships that can exist between instances of <code>ObjectTypeDefinition</code>s. It includes a unique name, allowed source and target object types, and any properties specific to the relation itself (edge properties).</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>:noindex: A unique name for the relation type (e.g., 'HAS_AUTHOR', 'REFERENCES'). Conventionally, UPPER_SNAKE_CASE is used.</p> <code>description</code> <code>Optional[str]</code> <p>:noindex: An optional human-readable description of what this relation type represents.</p> <code>source_object_type_names</code> <code>List[str]</code> <p>:noindex: A list of names of <code>ObjectTypeDefinition</code>s that are allowed as the source (or \"from\" side) of this relation.</p> <code>target_object_type_names</code> <code>List[str]</code> <p>:noindex: A list of names of <code>ObjectTypeDefinition</code>s that are allowed as the target (or \"to\" side) of this relation.</p> <code>properties</code> <code>List[PropertyDefinition]</code> <p>:noindex: A list of <code>PropertyDefinition</code>s that belong to the relation itself (often called edge properties). Defaults to an empty list if the relation has no properties.</p> Source code in <code>grizabella/core/models.py</code> <pre><code>class RelationTypeDefinition(BaseModel):\n    \"\"\"Defines the schema for a type of relation between objects (e.g., an edge in a graph).\n\n    A ``RelationTypeDefinition`` specifies the structure for relationships\n    that can exist between instances of ``ObjectTypeDefinition``s. It includes\n    a unique name, allowed source and target object types, and any properties\n    specific to the relation itself (edge properties).\n\n    Attributes:\n        name (str): :noindex: A unique name for the relation type (e.g., 'HAS_AUTHOR',\n            'REFERENCES'). Conventionally, UPPER_SNAKE_CASE is used.\n\n        description (Optional[str]): :noindex: An optional human-readable description\n            of what this relation type represents.\n\n        source_object_type_names (List[str]): :noindex: A list of names of\n            ``ObjectTypeDefinition``s that are allowed as the source (or \"from\" side)\n            of this relation.\n\n        target_object_type_names (List[str]): :noindex: A list of names of\n            ``ObjectTypeDefinition``s that are allowed as the target (or \"to\" side)\n            of this relation.\n\n        properties (List[PropertyDefinition]): :noindex: A list of ``PropertyDefinition``s that\n            belong to the relation itself (often called edge properties).\n            Defaults to an empty list if the relation has no properties.\n\n\n    \"\"\"\n\n    name: str = Field(\n        ...,\n        description=(\n            \"Unique name for the relation type (e.g., 'HAS_AUTHOR', 'REFERENCES'). \"\n            \"Convention: UPPER_SNAKE_CASE.\"\n        ),\n    )\n    description: Optional[str] = Field(\n        default=None,\n        description=\"Optional description of the relation type.\",\n    )\n    source_object_type_names: list[str] = Field(\n        ...,\n        description=\"List of names of allowed source ObjectTypeDefinitions.\",\n    )\n    target_object_type_names: list[str] = Field(\n        ...,\n        description=\"List of names of allowed target ObjectTypeDefinitions.\",\n    )\n    properties: list[PropertyDefinition] = Field(\n        default_factory=list,\n        description=\"Properties of the relation itself (edge properties).\",\n    )\n</code></pre>"},{"location":"api/mcp_server/","title":"MCP Server","text":""},{"location":"api/mcp_server/#grizabella.mcp.server","title":"<code>grizabella.mcp.server</code>","text":"<p>Grizabella MCP Server.</p> <p>This module provides an MCP (Model Context Protocol) server for Grizabella, exposing its core functionalities as tools that can be called remotely. It uses FastMCP to define and serve these tools.</p> <p>Server Description: This MCP server exposes the core functionalities of the Grizabella knowledge management system, allowing for the creation, retrieval, and querying of structured data objects and their relationships.</p>"},{"location":"api/mcp_server/#grizabella.mcp.server.cleanup_resources","title":"<code>cleanup_resources()</code>","text":"<p>Perform cleanup of all resources.</p> Source code in <code>grizabella/mcp/server.py</code> <pre><code>def cleanup_resources():\n    \"\"\"Perform cleanup of all resources.\"\"\"\n    logger.info(\"Starting resource cleanup...\")\n\n    # Clean up database connections\n    try:\n        pool_manager = ConnectionPoolManager()\n        pool_manager.close_all_pools()\n        logger.info(\"Connection pools closed\")\n    except Exception as e:\n        logger.error(f\"Error closing connection pools: {e}\")\n\n    # Clean up DB managers\n    try:\n        cleanup_all_managers()\n        logger.info(\"DB managers cleaned up\")\n    except Exception as e:\n        logger.error(f\"Error cleaning up DB managers: {e}\")\n\n    # Stop monitoring\n    try:\n        stop_global_monitoring()\n        logger.info(\"Resource monitoring stopped\")\n    except Exception as e:\n        logger.error(f\"Error stopping resource monitoring: {e}\")\n\n    # Force garbage collection\n    try:\n        import gc\n        collected = gc.collect()\n        logger.info(f\"Garbage collector cleaned up {collected} objects\")\n    except Exception as e:\n        logger.error(f\"Error during garbage collection: {e}\")\n\n    logger.info(\"Resource cleanup completed\")\n</code></pre>"},{"location":"api/mcp_server/#grizabella.mcp.server.get_grizabella_client","title":"<code>get_grizabella_client()</code>","text":"<p>Returns the shared Grizabella client instance.</p> Source code in <code>grizabella/mcp/server.py</code> <pre><code>def get_grizabella_client() -&gt; Grizabella:\n    \"\"\"Returns the shared Grizabella client instance.\"\"\"\n    if grizabella_client_instance is None:\n        raise GrizabellaException(\"Grizabella client is not initialized.\")\n    return grizabella_client_instance\n</code></pre>"},{"location":"api/mcp_server/#grizabella.mcp.server.get_grizabella_db_path","title":"<code>get_grizabella_db_path(db_path_arg=None)</code>","text":"<p>Determines the database path from arg, env var, or default.</p> Source code in <code>grizabella/mcp/server.py</code> <pre><code>def get_grizabella_db_path(db_path_arg: Optional[str] = None) -&gt; Union[str, Path]:\n    \"\"\"Determines the database path from arg, env var, or default.\"\"\"\n    if db_path_arg:\n        return db_path_arg\n    return os.getenv(GRIZABELLA_DB_PATH_ENV_VAR, DEFAULT_GRIZABELLA_DB_PATH)\n</code></pre>"},{"location":"api/mcp_server/#grizabella.mcp.server.log_tool_call","title":"<code>log_tool_call(func)</code>","text":"<p>Decorator to log detailed information about tool calls.</p> Source code in <code>grizabella/mcp/server.py</code> <pre><code>def log_tool_call(func):\n    \"\"\"Decorator to log detailed information about tool calls.\"\"\"\n    @functools.wraps(func)\n    async def wrapper(*args, **kwargs):\n        # Extract tool name from function name (remove mcp_ prefix)\n        tool_name = func.__name__\n        if tool_name.startswith('mcp_'):\n            tool_name = tool_name[4:]\n\n        # Log the tool call with details\n        logger.info(f\"\ud83d\udd27 Tool Call: {tool_name}\")\n\n        # Log arguments if any (excluding 'self' for methods)\n        if args:\n            # Skip 'self' argument for methods\n            actual_args = args[1:] if args and hasattr(args[0], '__class__') else args\n            if actual_args:\n                logger.info(f\"\ud83d\udcdd Arguments: {actual_args}\")\n\n        if kwargs:\n            logger.info(f\"\ud83d\udcdd Keyword Arguments: {kwargs}\")\n\n        # Call the original function\n        try:\n            result = await func(*args, **kwargs)\n            logger.info(f\"\u2705 Tool Call Success: {tool_name}\")\n            return result\n        except Exception as e:\n            logger.error(f\"\u274c Tool Call Failed: {tool_name} - Error: {e}\")\n            raise\n\n    return wrapper\n</code></pre>"},{"location":"api/mcp_server/#grizabella.mcp.server.main","title":"<code>main()</code>","text":"<p>Initializes client and runs the FastMCP application.</p> Source code in <code>grizabella/mcp/server.py</code> <pre><code>def main():\n    \"\"\"Initializes client and runs the FastMCP application.\"\"\"\n    # Register signal handlers\n    signal.signal(signal.SIGINT, shutdown_handler)\n    signal.signal(signal.SIGTERM, shutdown_handler)\n\n    parser = argparse.ArgumentParser(description=\"Grizabella MCP Server\")\n    parser.add_argument(\"--db-path\", help=\"Path to the Grizabella database.\")\n    args = parser.parse_args()\n\n    global grizabella_client_instance\n    db_path = get_grizabella_db_path(args.db_path)\n\n    try:\n        with Grizabella(db_name_or_path=db_path, create_if_not_exists=True) as gb:\n            grizabella_client_instance = gb\n            app.run(show_banner=False)\n    except Exception as e:\n        print(f\"Server error: {e}\", file=sys.stderr)\n        logger.error(f\"Server error: {e}\", exc_info=True)\n        sys.exit(1)\n    finally:\n        # Ensure clean termination\n        grizabella_client_instance = None\n        cleanup_resources()\n        print(\"Server terminated cleanly\", file=sys.stderr)\n\n        sys.exit(0)\n</code></pre>"},{"location":"api/mcp_server/#grizabella.mcp.server.mcp_find_objects","title":"<code>mcp_find_objects(type_name, filter_criteria=None, limit=None)</code>  <code>async</code>","text":"<p>Finds and retrieves a list of objects of a given type, with optional filtering criteria.</p> Source code in <code>grizabella/mcp/server.py</code> <pre><code>@app.tool(\n    name=\"find_objects\",\n    description=(\n        \"Finds and retrieves a list of objects of a given type, with optional filtering criteria.\\n\\n\"\n        \"Example:\\n\"\n        \"To find all 'Person' objects where the age is greater than 30:\\n\"\n        '{\\n'\n        '  \"args\": {\\n'\n        '    \"type_name\": \"Person\",\\n'\n        '    \"filter_criteria\": {\\n'\n        '      \"age\": {\"&gt;\": 30}\\n'\n        '    },\\n'\n        '    \"limit\": 10\\n'\n        '  }\\n'\n        '}'\n    ),\n)\nasync def mcp_find_objects(\n    type_name: str,\n    filter_criteria: Optional[dict[str, Any]] = None,\n    limit: Optional[int] = None,\n) -&gt; list[ObjectInstance]:\n    \"\"\"Finds and retrieves a list of objects of a given type, with optional filtering criteria.\n    \"\"\"\n    # ctx: ToolContext,\n    try:\n        gb = get_grizabella_client()\n        return gb.find_objects(\n            type_name=type_name,\n            filter_criteria=filter_criteria,\n            limit=limit,\n        )\n    except GrizabellaException as e:\n        msg = f\"MCP: Error finding objects of type '{type_name}': {e}\"\n        raise GrizabellaException(msg) from e\n    except Exception as e:  # pylint: disable=broad-except\n        msg = f\"MCP: Unexpected error finding objects of type '{type_name}': {e}\"\n        raise Exception(msg) from e\n</code></pre>"},{"location":"api/mcp_server/#grizabella.mcp.server.mcp_get_embedding_vector_for_text","title":"<code>mcp_get_embedding_vector_for_text(args)</code>  <code>async</code>","text":"<p>Generates an embedding vector for a given text using a specified embedding definition.</p> Source code in <code>grizabella/mcp/server.py</code> <pre><code>@app.tool(\n    name=\"get_embedding_vector_for_text\",\n    description=\"Generates an embedding vector for a given text using a specified embedding definition.\",\n)\n@log_tool_call\nasync def mcp_get_embedding_vector_for_text(args: GetEmbeddingVectorForTextArgs) -&gt; EmbeddingVector:\n    \"\"\"Generates an embedding vector for a given text using a specified embedding definition.\"\"\"\n    gb = get_grizabella_client()\n    embedding_def = gb.get_embedding_definition(args.embedding_definition_name)\n    try:\n        # 1. Get the embedding definition\n        if not embedding_def:\n            raise GrizabellaException(f\"Embedding definition '{args.embedding_definition_name}' not found.\")\n\n        # 2. Generate embedding vector directly using the same logic as find_similar_objects_by_embedding\n        # This approach mirrors the Python client's successful method\n        logger.info(f\"Generating embedding vector for text using model '{embedding_def.embedding_model}'\")\n\n        # Get the embedding model function\n        # Strip 'huggingface/' prefix if present, as LanceDB registry expects just the model name\n        model_identifier = embedding_def.embedding_model\n        if model_identifier.startswith('huggingface/'):\n            model_identifier = model_identifier[len('huggingface/'):]\n            logger.info(f\"Stripped 'huggingface/' prefix from model identifier: '{embedding_def.embedding_model}' -&gt; '{model_identifier}'\")\n\n        logger.info(f\"About to load embedding model with identifier: '{model_identifier}'\")\n        embedding_model_func = gb._db_manager._connection_helper.lancedb_adapter.get_embedding_model(\n            model_identifier,\n        )\n\n        # Generate embedding using compute_query_embeddings (same as Python client)\n        raw_query_embeddings = embedding_model_func.compute_query_embeddings([args.text_to_embed])\n        if not raw_query_embeddings:\n            logger.error(f\"Model '{embedding_def.embedding_model}' returned empty list for text.\")\n            raise GrizabellaException(f\"Model {embedding_def.embedding_model} returned empty list for text.\")\n\n        raw_query_vector = raw_query_embeddings[0]\n\n        # Convert to list if it's a numpy array\n        if hasattr(raw_query_vector, \"tolist\"):  # Handles numpy array\n            final_query_vector = raw_query_vector.tolist()\n        elif isinstance(raw_query_vector, list):\n            final_query_vector = raw_query_vector\n        else:\n            logger.error(f\"Unexpected query vector type from model '{embedding_def.embedding_model}': {type(raw_query_vector)}\")\n            raise GrizabellaException(f\"Unexpected query vector type from model {embedding_def.embedding_model}\")\n\n        # Validate dimensions (temporarily disabled for debugging)\n        logger.info(f\"Generated embedding vector with {len(final_query_vector)} dimensions. ED specifies {embedding_def.dimensions} dimensions.\")\n        if embedding_def.dimensions and len(final_query_vector) != embedding_def.dimensions:\n            logger.warning(\n                f\"Query vector dim ({len(final_query_vector)}) does not match ED \"\n                f\"'{embedding_def.name}' dim ({embedding_def.dimensions}). Continuing anyway.\"\n            )\n            # raise GrizabellaException(msg)  # Temporarily disabled\n\n        logger.info(f\"Successfully generated embedding vector with dimension {len(final_query_vector)}\")\n\n        # Debug: Log what we're about to return\n        debug_return_value = {\"vector\": final_query_vector}\n        logger.info(f\"MCP get_embedding_vector_for_text returning: type={type(debug_return_value)}, vector_type={type(debug_return_value['vector'])}, vector_length={len(debug_return_value['vector'])}\")\n        logger.info(f\"MCP get_embedding_vector_for_text return value preview: {debug_return_value['vector'][:5]}...\")\n\n        # Return as a plain dict to ensure MCP serialization works correctly\n        return debug_return_value\n\n    except Exception as e:\n        logger.error(f\"Failed to generate embedding vector: {e}\", exc_info=True)\n        raise GrizabellaException(f\"Failed to generate embedding vector: {e}\") from e\n</code></pre>"},{"location":"api/mcp_server/#grizabella.mcp.server.mcp_get_incoming_relations","title":"<code>mcp_get_incoming_relations(object_id, type_name, relation_type_name=None)</code>  <code>async</code>","text":"<p>Retrieves all incoming relations to a specific object.</p> Source code in <code>grizabella/mcp/server.py</code> <pre><code>@app.tool(\n    name=\"get_incoming_relations\",\n    description=(\n        \"Retrieves all incoming relations to a specific object.\\n\\n\"\n        \"Example:\\n\"\n        \"To get all incoming relations to Jane Doe's 'Person' object:\\n\"\n        '{\\n'\n        '  \"args\": {\\n'\n        '    \"object_id\": \"jane_doe_456\",\\n'\n        '    \"type_name\": \"Person\"\\n'\n        '  }\\n'\n        '}'\n    ),\n)\nasync def mcp_get_incoming_relations(\n    object_id: str, type_name: str, relation_type_name: Optional[str] = None,\n) -&gt; list[RelationInstance]:\n    \"\"\"Retrieves all incoming relations to a specific object.\n    \"\"\"\n    # ctx: ToolContext,\n    try:\n        gb = get_grizabella_client()\n        return gb.get_incoming_relations(\n            object_id=object_id,\n            type_name=type_name,\n            relation_type_name=relation_type_name,\n        )\n    except GrizabellaException as e:\n        msg = f\"MCP: Error getting incoming relations for object '{object_id}': {e}\"\n        raise GrizabellaException(msg) from e\n    except Exception as e:  # pylint: disable=broad-except\n        msg = f\"MCP: Unexpected error getting incoming relations for object '{object_id}': {e}\"\n        raise Exception(msg) from e\n</code></pre>"},{"location":"api/mcp_server/#grizabella.mcp.server.mcp_get_outgoing_relations","title":"<code>mcp_get_outgoing_relations(object_id, type_name, relation_type_name=None)</code>  <code>async</code>","text":"<p>Retrieves all outgoing relations from a specific object.</p> Source code in <code>grizabella/mcp/server.py</code> <pre><code>@app.tool(\n    name=\"get_outgoing_relations\",\n    description=(\n        \"Retrieves all outgoing relations from a specific object.\\n\\n\"\n        \"Example:\\n\"\n        \"To get all outgoing relations from John Doe's 'Person' object:\\n\"\n        '{\\n'\n        '  \"args\": {\\n'\n        '    \"object_id\": \"john_doe_123\",\\n'\n        '    \"type_name\": \"Person\"\\n'\n        '  }\\n'\n        '}'\n    ),\n)\nasync def mcp_get_outgoing_relations(\n    object_id: str, type_name: str, relation_type_name: Optional[str] = None,\n) -&gt; list[RelationInstance]:\n    \"\"\"Retrieves all outgoing relations from a specific object.\n    \"\"\"\n    # ctx: ToolContext,\n    try:\n        gb = get_grizabella_client()\n        return gb.get_outgoing_relations(\n            object_id=object_id,\n            type_name=type_name,\n            relation_type_name=relation_type_name,\n        )\n    except GrizabellaException as e:\n        msg = f\"MCP: Error getting outgoing relations for object '{object_id}': {e}\"\n        raise GrizabellaException(msg) from e\n    except Exception as e:  # pylint: disable=broad-except\n        msg = f\"MCP: Unexpected error getting outgoing relations for object '{object_id}': {e}\"\n        raise Exception(msg) from e\n</code></pre>"},{"location":"api/mcp_server/#grizabella.mcp.server.mcp_search_similar_objects","title":"<code>mcp_search_similar_objects(object_id, type_name, n_results=5, search_properties=None)</code>  <code>async</code>","text":"<p>Searches for objects that are semantically similar to a given object, based on embeddings of their properties.</p> Source code in <code>grizabella/mcp/server.py</code> <pre><code>@app.tool(\n    name=\"search_similar_objects\",\n    description=(\n        \"Searches for objects that are semantically similar to a given object, based on embeddings \"\n        \"of their properties. Note: This feature is not yet fully implemented.\\n\\n\"\n        \"Example:\\n\"\n        \"To find 5 objects similar to John Doe's 'Person' object:\\n\"\n        '{\\n'\n        '  \"args\": {\\n'\n        '    \"object_id\": \"john_doe_123\",\\n'\n        '    \"type_name\": \"Person\",\\n'\n        '    \"n_results\": 5\\n'\n        '  }\\n'\n        '}'\n    ),\n)\nasync def mcp_search_similar_objects(\n    object_id: str,\n    type_name: str,\n    n_results: int = 5,\n    search_properties: Optional[list[str]] = None,\n) -&gt; list[tuple[ObjectInstance, float]]:\n    \"\"\"Searches for objects that are semantically similar to a given object, based on embeddings of their properties.\n    \"\"\"\n    # ctx: ToolContext,\n    try:\n        gb = get_grizabella_client()\n        # The Grizabella client's search_similar_objects currently raises NotImplementedError.\n        # We must call it to respect the interface, but handle the expected error.\n        # If it were implemented, results would be List[Tuple[ObjectInstance, float]].\n        # For now, to satisfy Pylint and type checkers if the method were to return,\n        # we can assign and then immediately handle the expected NotImplementedError.\n        # However, a cleaner approach is to directly call and handle.\n\n        # Attempt the call and handle NotImplementedError specifically.\n        # Other GrizabellaExceptions or general Exceptions will be caught below.\n        try:\n            # This line will raise NotImplementedError based on current client.py\n            results: list[\n                tuple[ObjectInstance, float]\n            ] = gb.search_similar_objects(\n                object_id=object_id,\n                type_name=type_name,\n                n_results=n_results,\n                search_properties=search_properties,\n            )\n            return results  # This line will not be reached if NotImplementedError is raised\n        except NotImplementedError as nie:\n            # Specific handling for the known unimplemented feature.\n            # Raising a general Exception here for the MCP layer is acceptable to signal this state.\n            msg = f\"MCP: search_similar_objects feature is not yet implemented in the Grizabella client: {nie}\"\n            raise Exception(msg) from nie\n\n    except GrizabellaException as e:\n        # Handle other Grizabella-specific errors, re-raise as GrizabellaException\n        msg = f\"MCP: Error searching similar objects for '{object_id}': {e}\"\n        raise GrizabellaException(msg) from e\n    except Exception as e:  # pylint: disable=broad-except\n        # Handle any other unexpected errors, re-raise as general Exception\n        msg = f\"MCP: Unexpected error searching similar objects for '{object_id}': {e}\"\n        raise Exception(msg) from e\n</code></pre>"},{"location":"api/mcp_server/#grizabella.mcp.server.shutdown_handler","title":"<code>shutdown_handler(signum, frame)</code>","text":"<p>Handle shutdown signals gracefully.</p> Source code in <code>grizabella/mcp/server.py</code> <pre><code>def shutdown_handler(signum, frame):\n    \"\"\"Handle shutdown signals gracefully.\"\"\"\n    print(f\"Received signal {signum}, shutting down...\", file=sys.stderr)\n    logger.info(f\"Received signal {signum}, shutting down...\")\n\n    # Perform cleanup\n    cleanup_resources()\n\n    sys.exit(0)\n</code></pre>"},{"location":"api/query_models/","title":"Query Models","text":""},{"location":"api/query_models/#grizabella.core.query_models","title":"<code>grizabella.core.query_models</code>","text":"<p>Pydantic models for Grizabella Complex Query Engine.</p>"},{"location":"api/query_models/#grizabella.core.query_models.ComplexQuery","title":"<code>ComplexQuery</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a complex query that can span multiple database layers and object types.</p> Source code in <code>grizabella/core/query_models.py</code> <pre><code>class ComplexQuery(BaseModel):\n    \"\"\"Represents a complex query that can span multiple database layers and object types.\"\"\"\n\n    description: Optional[str] = Field(\n        default=None,\n        description=\"Optional user-defined description for the query.\",\n    )\n\n    # The new field for the logical query structure\n    query_root: Optional[QueryClause] = Field(\n        default=None,\n        description=\"The root of the logical query tree.\",\n    )\n\n    # The original field, kept for backward compatibility\n    components: Optional[List[\"QueryComponent\"]] = Field(\n        default=None,\n        description=\"[DEPRECATED] List of query components. Use 'query_root' for new queries.\",\n    )\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def check_exclusive_fields(cls, values):\n        \"\"\"Ensure that either 'components' or 'query_root' is provided, but not both.\"\"\"\n        components = values.get(\"components\")\n        query_root = values.get(\"query_root\")\n\n        if components is not None and query_root is not None:\n            raise ValueError(\"Cannot specify both 'components' and 'query_root'.\")\n\n        if components is None and query_root is None:\n            raise ValueError(\"Must specify either 'components' or 'query_root'.\")\n\n        return values\n</code></pre>"},{"location":"api/query_models/#grizabella.core.query_models.ComplexQuery.check_exclusive_fields","title":"<code>check_exclusive_fields(values)</code>  <code>classmethod</code>","text":"<p>Ensure that either 'components' or 'query_root' is provided, but not both.</p> Source code in <code>grizabella/core/query_models.py</code> <pre><code>@model_validator(mode=\"before\")\n@classmethod\ndef check_exclusive_fields(cls, values):\n    \"\"\"Ensure that either 'components' or 'query_root' is provided, but not both.\"\"\"\n    components = values.get(\"components\")\n    query_root = values.get(\"query_root\")\n\n    if components is not None and query_root is not None:\n        raise ValueError(\"Cannot specify both 'components' and 'query_root'.\")\n\n    if components is None and query_root is None:\n        raise ValueError(\"Must specify either 'components' or 'query_root'.\")\n\n    return values\n</code></pre>"},{"location":"api/query_models/#grizabella.core.query_models.EmbeddingSearchClause","title":"<code>EmbeddingSearchClause</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines a search based on embedding similarity.</p> <p>This clause is used within a <code>QueryComponent</code> to find objects that are semantically similar to a given query vector, based on pre-computed embeddings.</p> <p>Attributes:</p> Name Type Description <code>embedding_definition_name</code> <code>str</code> <p>:noindex: The name of the <code>EmbeddingDefinition</code> to use for this search. This definition specifies the model and source property used to generate the embeddings being searched.</p> <code>similar_to_payload</code> <code>List[float]</code> <p>:noindex: The embedding vector to find similarities against. This vector should have the same dimensions as specified in the <code>EmbeddingDefinition</code>.</p> <code>threshold</code> <code>Optional[float]</code> <p>:noindex: An optional similarity score threshold. Only results with a similarity score greater than or equal to this threshold will be returned. If None, no threshold is applied.</p> <code>limit</code> <code>int</code> <p>:noindex: The maximum number of similar items to retrieve and consider from this clause. Defaults to 10.</p> Source code in <code>grizabella/core/query_models.py</code> <pre><code>class EmbeddingSearchClause(BaseModel):\n    \"\"\"Defines a search based on embedding similarity.\n\n    This clause is used within a ``QueryComponent`` to find objects that are\n    semantically similar to a given query vector, based on pre-computed\n    embeddings.\n\n    Attributes:\n        embedding_definition_name (str): :noindex: The name of the ``EmbeddingDefinition``\n            to use for this search. This definition specifies the model and\n            source property used to generate the embeddings being searched.\n\n        similar_to_payload (List[float]): :noindex: The embedding vector to find\n            similarities against. This vector should have the same dimensions\n            as specified in the ``EmbeddingDefinition``.\n\n        threshold (Optional[float]): :noindex: An optional similarity score threshold.\n            Only results with a similarity score greater than or equal to this\n            threshold will be returned. If None, no threshold is applied.\n\n        limit (int): :noindex: The maximum number of similar items to retrieve and\n            consider from this clause. Defaults to 10.\n\n\n    \"\"\"\n\n    embedding_definition_name: str = Field(\n        ...,\n        description=\"Name of the EmbeddingDefinition to use for this search.\",\n    )\n    similar_to_payload: list[float] = Field(\n        ...,\n        description=\"The embedding vector to find similarities against.\",\n    )\n    # similar_to_object_id: Optional[UUID] = Field(\n    #     default=None,\n    #     description=\"Alternatively, specify an object ID whose embedding should be used as the query vector.\"\n    # )\n    # similar_to_object_type_name: Optional[str] = Field(\n    #     default=None,\n    #     description=\"Required if similar_to_object_id is specified.\"\n    # )\n    threshold: Optional[float] = Field(\n        default=None,\n        description=\"Optional similarity threshold. Only results above this score are returned.\",\n    )\n    limit: int = Field(\n        default=10,\n        description=\"Maximum number of similar items to consider from this clause.\",\n    )\n    is_l2_distance: bool = Field(\n        default=False,\n        description=\"If True, indicates that the threshold is for L2 distance (smaller is better) \"\n                    \"and the QueryEngine should not convert distance to cosine similarity.\",\n    )\n</code></pre>"},{"location":"api/query_models/#grizabella.core.query_models.EmbeddingVector","title":"<code>EmbeddingVector</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A container for a list of floats representing an embedding vector.</p> Source code in <code>grizabella/core/query_models.py</code> <pre><code>class EmbeddingVector(BaseModel):\n    \"\"\"A container for a list of floats representing an embedding vector.\"\"\"\n\n    vector: list[float]\n</code></pre>"},{"location":"api/query_models/#grizabella.core.query_models.GraphTraversalClause","title":"<code>GraphTraversalClause</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines a graph traversal condition from a source object set.</p> <p>This clause is used within a <code>QueryComponent</code> to navigate relationships in the graph database. It specifies the type of relation to follow, the direction of traversal, and conditions on the target objects.</p> <p>Attributes:</p> Name Type Description <code>relation_type_name</code> <code>str</code> <p>:noindex: The name of the <code>RelationTypeDefinition</code> that defines the type of relationship to traverse.</p> <code>direction</code> <code>Literal['outgoing', 'incoming']</code> <p>:noindex: The direction of the traversal from the current set of source objects. \"outgoing\" means following relations where the current objects are the source; \"incoming\" means following relations where they are the target. Defaults to \"outgoing\".</p> <code>target_object_type_name</code> <code>str</code> <p>:noindex: The expected <code>ObjectTypeDefinition</code> name of the target node(s) at the end of the traversal.</p> <code>target_object_id</code> <code>Optional[UUID]</code> <p>:noindex: An optional specific ID of a target object. If provided, the traversal will only consider paths leading to this specific object.</p> <code>target_object_properties</code> <code>Optional[List[RelationalFilter]]</code> <p>:noindex: Optional list of <code>RelationalFilter</code>s to apply to the properties of the target object(s) found by the traversal.</p> Source code in <code>grizabella/core/query_models.py</code> <pre><code>class GraphTraversalClause(BaseModel):\n    \"\"\"Defines a graph traversal condition from a source object set.\n\n    This clause is used within a ``QueryComponent`` to navigate relationships\n    in the graph database. It specifies the type of relation to follow,\n    the direction of traversal, and conditions on the target objects.\n\n    Attributes:\n        relation_type_name (str): :noindex: The name of the ``RelationTypeDefinition``\n            that defines the type of relationship to traverse.\n\n        direction (Literal[\"outgoing\", \"incoming\"]): :noindex: The direction of the\n            traversal from the current set of source objects. \"outgoing\" means\n            following relations where the current objects are the source;\n            \"incoming\" means following relations where they are the target.\n            Defaults to \"outgoing\".\n\n        target_object_type_name (str): :noindex: The expected ``ObjectTypeDefinition`` name\n            of the target node(s) at the end of the traversal.\n\n        target_object_id (Optional[UUID]): :noindex: An optional specific ID of a target\n            object. If provided, the traversal will only consider paths leading\n            to this specific object.\n\n        target_object_properties (Optional[List[RelationalFilter]]): :noindex: Optional\n            list of ``RelationalFilter``s to apply to the properties of the\n            target object(s) found by the traversal.\n\n\n    \"\"\"\n\n    relation_type_name: str = Field(\n        ...,\n        description=\"Name of the RelationTypeDefinition to traverse.\",\n    )\n    direction: Literal[\"outgoing\", \"incoming\"] = Field(\n        default=\"outgoing\",\n        description=\"Direction of the traversal from the source object.\",\n    )\n    target_object_type_name: str = Field(\n        ...,\n        description=\"Expected ObjectTypeDefinition name of the target node(s).\",\n    )\n    target_object_id: Optional[UUID] = Field(\n        default=None,\n        description=\"Optional specific ID of the target object.\",\n    )\n    target_object_properties: Optional[list[RelationalFilter]] = Field(\n        default=None,\n        description=\"Optional filters to apply to the properties of the target object(s).\",\n    )\n</code></pre>"},{"location":"api/query_models/#grizabella.core.query_models.LogicalGroup","title":"<code>LogicalGroup</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a group of query clauses combined by a single logical operator.</p> Source code in <code>grizabella/core/query_models.py</code> <pre><code>class LogicalGroup(BaseModel):\n    \"\"\"Represents a group of query clauses combined by a single logical operator.\"\"\"\n\n    operator: LogicalOperator = Field(\n        ...,\n        description=\"The logical operator (AND, OR) to apply to the clauses in this group.\",\n    )\n    clauses: List[\"QueryClause\"] = Field(\n        ...,\n        description=\"A list of clauses to be combined. Clauses can be other LogicalGroups, NotClauses, or QueryComponents.\",\n    )\n</code></pre>"},{"location":"api/query_models/#grizabella.core.query_models.LogicalOperator","title":"<code>LogicalOperator</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Defines the logical operators for combining query clauses.</p> Source code in <code>grizabella/core/query_models.py</code> <pre><code>class LogicalOperator(str, Enum):\n    \"\"\"Defines the logical operators for combining query clauses.\"\"\"\n\n    AND = \"AND\"\n    OR = \"OR\"\n</code></pre>"},{"location":"api/query_models/#grizabella.core.query_models.NotClause","title":"<code>NotClause</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a logical NOT operation on a single query clause.</p> Source code in <code>grizabella/core/query_models.py</code> <pre><code>class NotClause(BaseModel):\n    \"\"\"Represents a logical NOT operation on a single query clause.\"\"\"\n\n    clause: \"QueryClause\" = Field(\n        ...,\n        description=\"The clause to be negated. Can be a LogicalGroup, another NotClause, or a QueryComponent.\",\n    )\n</code></pre>"},{"location":"api/query_models/#grizabella.core.query_models.QueryComponent","title":"<code>QueryComponent</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines a single logical block of query conditions targeting a primary object type.</p> <p>A <code>QueryComponent</code> groups various types of search and filter conditions that apply to a specific <code>ObjectTypeDefinition</code>. All conditions (relational filters, embedding searches, graph traversals) specified within a single component are implicitly ANDed together. The results from these conditions are intersected to produce a set of matching <code>ObjectInstance</code>s of the <code>object_type_name</code>.</p> <p>Attributes:</p> Name Type Description <code>object_type_name</code> <code>str</code> <p>:noindex: The primary <code>ObjectTypeDefinition</code> name that this component targets. The query starts by considering objects of this type.</p> <code>relational_filters</code> <code>Optional[List[RelationalFilter]]</code> <p>:noindex: A list of <code>RelationalFilter</code>s to apply to the properties of objects of <code>object_type_name</code>. Typically processed by a relational database layer.</p> <code>embedding_searches</code> <code>Optional[List[EmbeddingSearchClause]]</code> <p>:noindex: A list of <code>EmbeddingSearchClause</code>s to perform semantic similarity searches. Typically processed by a vector database layer.</p> <code>graph_traversals</code> <code>Optional[List[GraphTraversalClause]]</code> <p>:noindex: A list of <code>GraphTraversalClause</code>s to navigate relationships from or to objects of <code>object_type_name</code>. Typically processed by a graph database layer.</p> Source code in <code>grizabella/core/query_models.py</code> <pre><code>class QueryComponent(BaseModel):\n    \"\"\"Defines a single logical block of query conditions targeting a primary object type.\n\n    A ``QueryComponent`` groups various types of search and filter conditions\n    that apply to a specific ``ObjectTypeDefinition``. All conditions\n    (relational filters, embedding searches, graph traversals) specified\n    within a single component are implicitly ANDed together. The results\n    from these conditions are intersected to produce a set of matching\n    ``ObjectInstance``s of the ``object_type_name``.\n\n    Attributes:\n        object_type_name (str): :noindex: The primary ``ObjectTypeDefinition`` name that\n            this component targets. The query starts by considering objects\n            of this type.\n\n        relational_filters (Optional[List[RelationalFilter]]): :noindex: A list of\n            ``RelationalFilter``s to apply to the properties of objects of\n            ``object_type_name``. Typically processed by a relational database layer.\n\n        embedding_searches (Optional[List[EmbeddingSearchClause]]): :noindex: A list of\n            ``EmbeddingSearchClause``s to perform semantic similarity searches.\n            Typically processed by a vector database layer.\n\n        graph_traversals (Optional[List[GraphTraversalClause]]): :noindex: A list of\n            ``GraphTraversalClause``s to navigate relationships from or to\n            objects of ``object_type_name``. Typically processed by a graph\n            database layer.\n\n\n    \"\"\"\n\n    object_type_name: str = Field(\n        ...,\n        description=\"The primary ObjectTypeDefinition name this component targets.\",\n    )\n    relational_filters: Optional[list[RelationalFilter]] = Field(\n        default=None,\n        description=\"List of relational filters to apply (SQLite).\",\n    )\n    embedding_searches: Optional[list[EmbeddingSearchClause]] = Field(\n        default=None,\n        description=\"List of embedding similarity searches to apply (LanceDB).\",\n    )\n    graph_traversals: Optional[list[GraphTraversalClause]] = Field(\n        default=None,\n        description=\"List of graph traversals to apply (Kuzu).\",\n    )\n</code></pre>"},{"location":"api/query_models/#grizabella.core.query_models.QueryResult","title":"<code>QueryResult</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the result of a complex query execution.</p> <p>This model encapsulates the <code>ObjectInstance</code>s that match the criteria of a <code>ComplexQuery</code>, along with any errors that may have occurred during the query planning or execution process.</p> <p>Attributes:</p> Name Type Description <code>object_instances</code> <code>List[ObjectInstance]</code> <p>:noindex: A list of <code>ObjectInstance</code>s that satisfy all conditions of the <code>ComplexQuery</code>.</p> <code>errors</code> <code>Optional[List[str]]</code> <p>:noindex: A list of error messages encountered during the execution of the query. If the query was successful, this will be None or an empty list.</p> Source code in <code>grizabella/core/query_models.py</code> <pre><code>class QueryResult(BaseModel):\n    \"\"\"Represents the result of a complex query execution.\n\n    This model encapsulates the ``ObjectInstance``s that match the criteria\n    of a ``ComplexQuery``, along with any errors that may have occurred during\n    the query planning or execution process.\n\n    Attributes:\n        object_instances (List[ObjectInstance]): :noindex: A list of ``ObjectInstance``s\n            that satisfy all conditions of the ``ComplexQuery``.\n\n        errors (Optional[List[str]]): :noindex: A list of error messages encountered\n            during the execution of the query. If the query was successful,\n            this will be None or an empty list.\n\n\n    \"\"\"\n\n    object_instances: list[ObjectInstance] = Field(\n        default_factory=list,\n        description=\"List of ObjectInstances that match the complex query.\",\n    )\n    errors: Optional[list[str]] = Field(\n        default=None,\n        description=\"List of errors encountered during query execution, if any.\",\n    )\n</code></pre>"},{"location":"api/query_models/#grizabella.core.query_models.RelationalFilter","title":"<code>RelationalFilter</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines a filter condition based on an object's property value.</p> <p>This model is used within <code>QueryComponent</code> and <code>GraphTraversalClause</code> to specify conditions for filtering objects based on their properties. It allows for various comparison operators against a given value.</p> <p>Attributes:</p> Name Type Description <code>property_name</code> <code>str</code> <p>:noindex: The name of the property on which to apply the filter. This must match a property defined in the relevant <code>ObjectTypeDefinition</code>.</p> <code>operator</code> <code>Literal</code> <p>:noindex: The comparison operator to use. Supported operators include \"==\", \"!=\", \"&gt;\", \"&lt;\", \"&gt;=\", \"&lt;=\", \"LIKE\", \"IN\", \"CONTAINS\", \"STARTSWITH\", and \"ENDSWITH\".</p> <code>value</code> <code>FilterValueType</code> <p>:noindex: The value to compare the property against. The type of this value should be compatible with the data type of the specified property. For \"IN\" operator, this should be a list of values.</p> Source code in <code>grizabella/core/query_models.py</code> <pre><code>class RelationalFilter(BaseModel):\n    \"\"\"Defines a filter condition based on an object's property value.\n\n    This model is used within ``QueryComponent`` and ``GraphTraversalClause``\n    to specify conditions for filtering objects based on their properties.\n    It allows for various comparison operators against a given value.\n\n    Attributes:\n        property_name (str): :noindex: The name of the property on which to apply the filter.\n            This must match a property defined in the relevant ``ObjectTypeDefinition``.\n\n        operator (Literal): :noindex: The comparison operator to use. Supported operators\n            include \"==\", \"!=\", \"&gt;\", \"&lt;\", \"&gt;=\", \"&lt;=\", \"LIKE\", \"IN\", \"CONTAINS\",\n            \"STARTSWITH\", and \"ENDSWITH\".\n\n        value (FilterValueType): :noindex: The value to compare the property against. The type of this\n            value should be compatible with the data type of the specified property.\n            For \"IN\" operator, this should be a list of values.\n\n\n    \"\"\"\n\n    property_name: str = Field(\n        ...,\n        description=\"Name of the property to filter on.\",\n    )\n    operator: Literal[\n        \"==\", \"!=\", \"&gt;\", \"&lt;\", \"&gt;=\", \"&lt;=\", \"LIKE\", \"IN\",\n        \"CONTAINS\", \"STARTSWITH\", \"ENDSWITH\", # Added common operators\n    ] = Field(\n        ...,\n        description=\"The comparison operator.\",\n    )\n    value: FilterValueType = Field(\n        ...,\n        description=\"The value to compare against. For simple operators (==, !=, &gt;, &lt;, etc.), this can be a string, number, boolean, or null. For the 'IN' operator, this should be a list of values of the same type.\",\n    )\n</code></pre>"}]}